<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C 中的多进程编程 —— Advanced Operating Systems | Busyboxs</title><meta name="keywords" content="cpp"><meta name="author" content="Busyboxs"><meta name="copyright" content="Busyboxs"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Advanced Operating Systems  原文件为 PPT，这里是分页翻译的   目录多进程编程 Fork 进程 进程间同步 执行其他程序  进程间通信 信号 管道和有名管道 消息队列 共享内存 同步   多进程编程为什么要多进程编程 多进程意味着每个任务都有自己的地址空间 与多线程相比，任务隔离和独立性更高 可靠性：一个进程崩溃不会影响整个程序   对于任务对资源有重大要求的多任务">
<meta property="og:type" content="article">
<meta property="og:title" content="C 中的多进程编程 —— Advanced Operating Systems">
<meta property="og:url" content="https://busyboxs.github.io/blogs/3da05f76/index.html">
<meta property="og:site_name" content="Busyboxs">
<meta property="og:description" content="Advanced Operating Systems  原文件为 PPT，这里是分页翻译的   目录多进程编程 Fork 进程 进程间同步 执行其他程序  进程间通信 信号 管道和有名管道 消息队列 共享内存 同步   多进程编程为什么要多进程编程 多进程意味着每个任务都有自己的地址空间 与多线程相比，任务隔离和独立性更高 可靠性：一个进程崩溃不会影响整个程序   对于任务对资源有重大要求的多任务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/cpp.png">
<meta property="article:published_time" content="2020-03-10T07:08:41.000Z">
<meta property="article:modified_time" content="2020-03-10T07:24:37.265Z">
<meta property="article:author" content="Busyboxs">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/cpp.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://busyboxs.github.io/blogs/3da05f76/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google_site_verification" content="FwkuU16DW0uUtLvBlI63aK9-eCBhC55pVQMscORY34M"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0737f86b9c26e7c4269a4dec38cea0c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-158970947-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-158970947-1');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lacquer&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C 中的多进程编程 —— Advanced Operating Systems',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-03-10 15:24:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/img/archive_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Busyboxs</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C 中的多进程编程 —— Advanced Operating Systems</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-10T07:08:41.000Z" title="发表于 2020-03-10 15:08:41">2020-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-03-10T07:24:37.265Z" title="更新于 2020-03-10 15:24:37">2020-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cpp/">cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C 中的多进程编程 —— Advanced Operating Systems"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://home.deib.polimi.it/fornacia/doku.php?id=teaching_rtosmi">Advanced Operating Systems</a></p>
<blockquote>
<p>原文件为 PPT，这里是分页翻译的</p>
</blockquote>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h3><ul>
<li>Fork 进程</li>
<li>进程间同步</li>
<li>执行其他程序</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ul>
<li>信号</li>
<li>管道和有名管道</li>
<li>消息队列</li>
<li>共享内存</li>
<li>同步</li>
</ul>
<hr>
<h2 id="多进程编程-1"><a href="#多进程编程-1" class="headerlink" title="多进程编程"></a>多进程编程</h2><h3 id="为什么要多进程编程"><a href="#为什么要多进程编程" class="headerlink" title="为什么要多进程编程"></a>为什么要多进程编程</h3><ul>
<li>多进程意味着每个任务都有自己的地址空间<ul>
<li>与多线程相比，任务隔离和独立性更高</li>
<li>可靠性：一个进程崩溃不会影响整个程序</li>
</ul>
</li>
<li>对于任务对资源有重大要求的多任务应用程序是有用选择<ul>
<li>需要“较长”处理时间的任务</li>
<li>处理大数据结构的任务</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos001.png" alt=""></p>
<h3 id="实例-1-：fork-一个进程"><a href="#实例-1-：fork-一个进程" class="headerlink" title="实例 1 ：fork 一个进程"></a>实例 1 ：fork 一个进程</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main process id = %d (parent PID = %d)\n&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>(), (<span class="type">int</span>)  <span class="built_in">getppid</span>());</span><br><span class="line">    </span><br><span class="line">    child_pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child_pid != <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent: child&#x27;s process id = %d\n&quot;</span>, child_pid);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child:  my process id = %d\n&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>()); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fork()</code> 创建一个新的进程来复制调用进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc example1.c ­o fork_ex1</span><br><span class="line">$ ./fork_ex1</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Main process id = 9075 (parent PID = 32146) </span><br><span class="line">Parent: child&#x27;s process id = 9076 </span><br><span class="line">Child:  my process id = 9076</span><br></pre></td></tr></table></figure>
<ul>
<li>主线程 PID = 9075。它的父进程（PID=32146）是 shell，它是从 shell 程序中启动的</li>
<li>在 <code>fork()</code> 之后，程序并发执行两个进程</li>
<li>在父进程的地址空间中，将 <code>child_pid</code> 变量设置为 <code>fork</code> 的返回值(子进程 PID)</li>
<li>在子进程的地址空间中未设置 <code>child_pid</code> 变量(0)</li>
<li><code>getpid()</code> 返回当前进程标识号</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos002.png" alt=""></p>
<ul>
<li>子进程复制父进程虚拟地址空间<ul>
<li>包括变量，互斥量，条件变量，POSIX 对象的状态</li>
</ul>
</li>
<li>子进程继承父进程已打开的文件描述符集的副本<ul>
<li>以及状态标志和当前文件偏移</li>
</ul>
</li>
</ul>
<hr>
<h3 id="实例-2a"><a href="#实例-2a" class="headerlink" title="实例 2a"></a>实例 2a</h3><ul>
<li>两个进程将一些内容写入标准输出</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">char_at_a_time</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( *str!= <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>( *str++ );   <span class="comment">// Write a char and increment the pointer</span></span><br><span class="line">        <span class="built_in">fflush</span>( stdout );    <span class="comment">// Print out immediately (no buffering)</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>( fork() == <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">char_at_a_time</span>( <span class="string">&quot;.............&quot;</span> )</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">char_at_a_time</span>( <span class="string">&quot;|||||||||||||&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc forkme_sync1.cpp ­o forkme</span><br><span class="line">$ ./forkme</span><br><span class="line"></span><br><span class="line">|.|.|.|.|.|.|..||..|.|.|.|</span><br></pre></td></tr></table></figure>
<ul>
<li>并发导致不可预测的进程执行顺序</li>
<li>应用程序可能需要同步两个或多个进程的执行</li>
<li>父进程可能需要等待子进程完成<ul>
<li>父进程派生一个子进程来执行计算，并行进行，然后到达执行点，在此需要使用子进程的输出数据</li>
</ul>
</li>
<li>考虑我们的示例，假设这是我们想要的输出：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.............|||||||||||||</span><br></pre></td></tr></table></figure>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul>
<li>父进程可以阻塞自己，直到其中一个子进程发生状态更改为止<ul>
<li>子进程终止或停止</li>
<li>子进程通过信号恢复（请参阅下文）</li>
</ul>
</li>
<li>以指针方式传递的整数参数中检索状态</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> *status)</span></span>; </span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>waitpid(...)</code> 等待特定子进程的状态更改</li>
<li><code>wait/waitpid(...)</code> 允许系统释放与子进程相关的资源（例如，打开的文件，分配的内存等）</li>
</ul>
<h3 id="实例-2b-：以同步方式-fork-一个进程"><a href="#实例-2b-：以同步方式-fork-一个进程" class="headerlink" title="实例 2b ：以同步方式 fork 一个进程"></a>实例 2b ：以同步方式 fork 一个进程</h3><ul>
<li>通过使用 <code>wait(...)</code> 函数可以获得结果</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">char_at_a_time</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( *str!= <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>( *str++ );   <span class="comment">// Write a char and increment the pointer</span></span><br><span class="line">        <span class="built_in">fflush</span>( stdout );    <span class="comment">// Print out immediately (no buffering)</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( fork() == <span class="number">0</span> ) </span><br><span class="line">        <span class="built_in">char_at_a_time</span>( <span class="string">&quot;.............&quot;</span> );</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">wait</span>( <span class="literal">NULL</span> );</span><br><span class="line">        <span class="built_in">char_at_a_time</span>( <span class="string">&quot;|||||||||||||&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul>
<li>如果子进程在父进程没有执行 <code>wait()</code> 的情况下终止，则它将保持“僵尸”状态</li>
<li>Linux 内核维护有关僵尸进程的部分信息<ul>
<li>（PID，终止状态，资源使用信息，…）</li>
<li>父进程稍后可以 wait 以获得有关子进程的信息</li>
</ul>
</li>
<li>僵尸进程会占用内核进程表中的一个表项<ul>
<li>如果表格已填满，将无法创建进程</li>
</ul>
</li>
<li>如果父进程终止，则 <code>init</code> 进程将接管父进程的僵尸子进程（如果有）<ul>
<li><code>init</code> 自动执行 <code>wait</code> 以删除僵尸</li>
</ul>
</li>
</ul>
<h3 id="生成执行程序进程"><a href="#生成执行程序进程" class="headerlink" title="生成执行程序进程"></a>生成执行程序进程</h3><ul>
<li>进程派生基本上是“克隆”父进程的镜像<ul>
<li>相同的代码和相同的变量</li>
</ul>
</li>
<li>在多进程应用程序中，我们可能需要生成一个进程来执行完全不同的任务（程序）<ul>
<li>加载并运行另一个可执行文件</li>
</ul>
</li>
<li><code>exec()</code> 系列函数允许我们在另一个程序中启动一个程序</li>
<li><code>exec()</code> 系列函数通过加载新程序来替换当前进程映像</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... ,<span class="type">char</span> * <span class="type">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有函数均以可执行路径作为第一个参数</li>
<li><code>&quot;l&quot;</code> 函数接受可变数量的以 <code>null</code> 终止的 <code>char *</code></li>
<li><code>&quot;v&quot;</code> 函数接受可执行路径和以 <code>null</code> 终止的 <code>char *</code> 数组<ul>
<li>将两个前置参数都提交给可执行文件（必须将 <code>arg0</code> 设置为可执行文件名称）</li>
</ul>
</li>
<li><code>&quot;p&quot;</code> 函数访问 PATH 环境变量以查找可执行文件</li>
<li><code>&quot;e&quot;</code> 函数还接受以 <code>null</code> 终止的 <code>char *</code> 存储环境变量的数组</li>
</ul>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子 3"></a>例子 3</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spawn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * program, <span class="type">char</span> ** arg_list)</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> child_pid;      <span class="comment">/* This is the parent process.  */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">execvp</span> (program, arg_list);     <span class="comment">/* Now execute PROGRAM */</span></span><br><span class="line">        <span class="built_in">fprintf</span> (stderr, <span class="string">&quot;An error occurred in execvp\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> * arg_list[] = &#123; <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;­l&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="built_in">spawn</span>(<span class="string">&quot;ls&quot;</span>, arg_list);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Main program exiting...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos003.png" alt=""></p>
<hr>
<h2 id="进程间通信-1"><a href="#进程间通信-1" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><ul>
<li>每个进程都有自己的地址空间 -&gt; 如何在两个不同的进程间交换信息</li>
<li>操作系统在构建通信机制和 API 的基础上提供系统调用</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos004.png" alt=""></p>
<h3 id="POSIX-vs-System-V"><a href="#POSIX-vs-System-V" class="headerlink" title="POSIX vs System V"></a>POSIX vs System V</h3><ul>
<li>两者提供了相同的机制</li>
<li>POSIX 在 System V 之后诞生，用于标准化</li>
<li>POSIX 旨在简化和改进 System V</li>
<li>POSIX 函数是线程安全的</li>
<li>下一张幻灯片中的代码基于POSIX IPC</li>
</ul>
<hr>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>一位(bit)长的“消息”</li>
<li>没有数据交换</li>
<li>信号类型隐式提供信息内容</li>
<li>异步事件通知机制</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>Elapsed timer</li>
<li>I/O operation completion</li>
<li>程序异常</li>
<li>用户定义的事件</li>
</ul>
<h3 id="同步化"><a href="#同步化" class="headerlink" title="同步化"></a>同步化</h3><ul>
<li>发送方和接收方之间的异步交互</li>
<li>信号是事件的通知<ul>
<li>操作系统定义了一组绑定到信号编号的宏</li>
</ul>
</li>
<li>进程可以接收信号以异步响应来自软件或意外硬件事件的请求<ul>
<li>其他进程调用 <code>kill()</code> 之类的函数</li>
<li>进程本身会调用类似 <code>abort()</code> 的函数</li>
<li>子进程正在退出(<code>SIGCHLD</code>)</li>
<li>用户从键盘中断程序(<code>SIGINT</code>)</li>
<li>程序行为不正确(<code>SIGILL</code>, <code>SIGFPE</code>, <code>SIGSEGV</code>)</li>
<li>程序访问不可用的映射内存(<code>SIGSEV</code>)</li>
<li>程序通过 <code>write()</code> 发送数据，没有人接收(<code>SIGPIPE</code>)</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="最常见的-POSIX-信号"><a href="#最常见的-POSIX-信号" class="headerlink" title="最常见的 POSIX 信号"></a>最常见的 POSIX 信号</h3><p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos005.png" alt=""></p>
<h3 id="信号处理程序注册"><a href="#信号处理程序注册" class="headerlink" title="信号处理程序注册"></a>信号处理程序注册</h3><ul>
<li>操作系统为每个进程管理信号向量表</li>
<li>进程可以为每个信号注册一个自定义信号处理程序<ul>
<li>在 Linux OS 中，大多数情况下默认的处理程序行为是终止进程</li>
</ul>
</li>
<li><p><code>sigaction(...)</code> 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">( <span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>signum: 要处理的信号数</li>
<li>act: 适用于注册处理函数的新设置</li>
<li>oldact: 先前的设置<ul>
<li>如果不希望保存它们，请设置为 <code>NULL</code></li>
</ul>
</li>
</ul>
</li>
<li><p>sigaction 结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">  <span class="built_in">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">  <span class="built_in">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">  <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">  <span class="type">int</span>        sa_flags;</span><br><span class="line">  <span class="built_in">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>sa_handler: 指向处理函数的指针</li>
<li>sa_sigaction: 具有两个附加参数的替代处理函数<ul>
<li>提供有关接收信号的更多信息…</li>
</ul>
</li>
<li>sa_mask: 设置要在处理程序执行期间被阻止的信号</li>
<li>sa_flags: 允许修改信号处理过程的行为<ul>
<li>设置为 <code>SA_SIGINFO</code> 以便使用 <code>sa_sigaction</code> 作为处理程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="例子-4：用户定义信号处理"><a href="#例子-4：用户定义信号处理" class="headerlink" title="例子 4：用户定义信号处理"></a>例子 4：用户定义信号处理</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sig_atomic_t</span> sigusr1_count = <span class="number">0</span>;  <span class="comment">// Use atomic variable for safety</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> sig_num)</span> </span>&#123;</span><br><span class="line">    ++sigusr1_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = &amp;handler;</span><br><span class="line">    <span class="built_in">sigaction</span> (SIGUSR1, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Running process... (PID=%d)\n&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>());</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGUSR1 was raised %d times\n&quot;</span>, sigusr1_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>包含 <code>&lt;signal.h&gt;</code> 头文件</li>
<li>声明数据类型为 <code>sigaction</code> 的数据结构</li>
<li>清除 <code>sigaction</code> 数据结构，然后将 <code>sa_handler</code> 字段设置为指向 <code>handler()</code> 的函数</li>
<li>通过调用 <code>sigaction()</code> 函数为信号 <code>SIGUSR1</code> 注册信号处理程序</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$&gt; gcc example4.cpp ­o sig_example</span><br><span class="line">$&gt; ./sig_example Running process... (PID=16151)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SIGUSR1 was raised 1 <span class="built_in">times</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$&gt; <span class="built_in">kill</span> ­SIGUSR1 16151</span><br></pre></td></tr></table></figure>
<h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><ul>
<li><p>函数 <code>kill(..)</code> 和 <code>sigqueue(..)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>pid: 目标地进程 ID</li>
<li>sig: 信号编号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>value: 要追加的数据项</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">sigval</span> &#123;</span><br><span class="line">    <span class="type">int</span>    sival_int;    <span class="comment">// Integer value</span></span><br><span class="line">    <span class="type">void</span>  *sival_ptr;    <span class="comment">// Pointer to other type value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例子-4b：信号发送器程序（SIGUSR1）"><a href="#例子-4b：信号发送器程序（SIGUSR1）" class="headerlink" title="例子 4b：信号发送器程序（SIGUSR1）"></a>例子 4b：信号发送器程序（SIGUSR1）</h3><p><code>SIGUSR1</code> 信号发送到目标进程，并添加整数数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> target_pid = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">union</span> <span class="title class_">sigval</span> value = &#123; <span class="built_in">atoi</span>(argv[<span class="number">2</span>]) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sending USR1 to process %d...\n&quot;</span>, target_pid);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">sigqueue</span>(target_pid, SIGUSR1, value);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sigqueue: &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号信息"><a href="#信号信息" class="headerlink" title="信号信息"></a>信号信息</h3><ul>
<li>当指定 <code>SA_SIGINFO</code> 标志时，数据结构被定义为传递给信号处理程序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">siginfo_t</span> &#123;</span><br><span class="line">    <span class="type">int</span>      si_signo;     <span class="comment">/* Signal number */</span></span><br><span class="line">    <span class="type">int</span>      si_errno;     <span class="comment">/* An errno value */</span></span><br><span class="line">    <span class="type">int</span>      si_code;      <span class="comment">/* Signal code */</span></span><br><span class="line">    <span class="type">int</span>      si_trapno;    <span class="comment">/* Trap number that caused</span></span><br><span class="line"><span class="comment">                              hardware­generated signal</span></span><br><span class="line"><span class="comment">                              (unused on most architectures) */</span></span><br><span class="line">    <span class="type">pid_t</span>    si_pid;       <span class="comment">/* Sending process ID */</span></span><br><span class="line">    <span class="type">uid_t</span>    si_uid;       <span class="comment">/* Real user ID of sending process */</span></span><br><span class="line">    <span class="type">int</span>      si_status;    <span class="comment">/* Exit value or signal */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="例-4c：访问信号信息"><a href="#例-4c：访问信号信息" class="headerlink" title="例 4c：访问信号信息"></a>例 4c：访问信号信息</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler2</span><span class="params">(<span class="type">int</span> sig_num, <span class="type">siginfo_t</span> * info, <span class="type">void</span> * extra)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Signal number:   %d\n&quot;</span>, info­&gt;sig_no);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Signal code:     %d\n&quot;</span>, info­&gt;sig_code);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Sender process:  %d\n&quot;</span>, info­&gt;si_pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Sender user ID:  %d\n&quot;</span>, info­&gt;si_uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; Signal value:    %d\n&quot;</span>, info­&gt;si_value.sival_int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = &amp;handler2;</span><br><span class="line">    sa.sa_flags   = SA_SIGINFO;</span><br><span class="line">    <span class="built_in">sigaction</span> (SIGUSR1, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Running process... (PID=%d)\n&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>());</span><br><span class="line">    <span class="comment">/* ...  */</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGUSR1 was raised %d times\n&quot;</span>, sigusr1_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h3><ul>
<li><p>信号可以在进程级别或线程级别被阻止</p>
<ul>
<li>除了 <code>SIGKILL</code> 和 <code>SIGSTOP</code> （尝试将被忽略）</li>
<li>当进程/线程 “unmask” 信号时，稍后入队并进行管理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> curr, old;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGINT);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, &amp;old); <span class="comment">// set new mask</span></span><br><span class="line">    ...</span><br><span class="line">    ret = <span class="built_in">sigprocmask</span>(SIG_UNBLOCK, &amp;set, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// alternative: sigprocmask(SIG_SETMASK, &amp;old, NULL);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于线程，请使用 <code>POSIX</code> 线程库中的函数 <code>pthread_sigmask()</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3><ul>
<li>基于生产者/消费者模式<ul>
<li>生产者写，消费者读</li>
</ul>
</li>
<li>数据以先进先出（FIFO）的方式写入/读取</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos006.png" alt=""></p>
<ul>
<li>在 Linux 中，操作系统保证每次只能有一个进程访问管道</li>
<li><p>生产者（发送者）写入的数据由操作系统存储到缓冲区中，直到消费者（接收者）读取数据为止</p>
</li>
<li><p>POSIX 提供函数调用 <code>pipe(...)</code>，以在相关进程之间创建单向FIFO 通信通道</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>   <span class="comment">// Obtain O_* constant definitions </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe2</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>], <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>pipefd: 用两个文件描述符填充的整数数组<ul>
<li>pipefd[0] : 管道读端</li>
<li>pipefd[1] : 管道写段</li>
</ul>
</li>
<li>flags: if =0 same of pipe()<ul>
<li><code>O_CLOEXEC</code> : 在执行 <code>exec(...)</code> 调用的情况下关闭文件描述符</li>
<li><code>O_DIRECT</code> : 在 “packet” 模式下执行I / O</li>
<li><code>O_NONBLOCK</code> : 避免在管道为空/满的情况下阻止读/写</li>
</ul>
</li>
<li>然后，我们可以使用普通函数来访问文件</li>
</ul>
</li>
</ul>
<h3 id="例5：简单的基于无名管道的消息传递"><a href="#例5：简单的基于无名管道的消息传递" class="headerlink" title="例5：简单的基于无名管道的消息传递"></a>例5：简单的基于无名管道的消息传递</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write COUNT copies of MESSAGE to STREAM, pausing for a second between each.  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * message, <span class="type">int</span> count, FILE * stream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; count &gt; <span class="number">0</span>; ­­--count) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stream, <span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">        <span class="built_in">fflush</span>(stream);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">(FILE * stream)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">/* Read until we hit the end of the stream.  fgets reads untileither a newline or the end­of­file.  */</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(stream) &amp;&amp; !<span class="built_in">ferror</span>(stream)</span><br><span class="line">          &amp;&amp; <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), stream) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fputs</span>(buffer, stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE * stream;</span><br><span class="line">    <span class="comment">/* Create pipe place the two ends pipe file descriptors in fds */</span></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == (<span class="type">pid_t</span>) <span class="number">0</span>) &#123; <span class="comment">/* Child process (consumer) */</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);          <span class="comment">/* Close the copy of the fds write end */</span></span><br><span class="line">        stream = <span class="built_in">fdopen</span>(fds[<span class="number">0</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="built_in">reader</span>(stream);</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;                   <span class="comment">/* Parent process (producer)  */</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);         <span class="comment">/* Close the copy of the fds read end */</span></span><br><span class="line">        stream = <span class="built_in">fdopen</span>(fds[<span class="number">1</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="built_in">writer</span>(<span class="string">&quot;Hello, world.&quot;</span>, <span class="number">3</span>, stream);</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>pipe()</code> 调用创建管道并初始化文件描述符 <code>“fds”</code> 的数组</li>
<li>fork 一个子进程作为消费者<ul>
<li>关闭管道文件描述符数组的写端</li>
<li>打开管道文件描述符数组的读端</li>
<li>调用 <code>reader()</code> 函数从管道读取数据</li>
</ul>
</li>
<li><p>父进程作为生产者</p>
<ul>
<li>关闭管道文件描述符数组的读端</li>
<li>打开管道文件描述符数组的写端</li>
<li>调用 <code>writer()</code> 函数编写 3 次 <code>“Hello，world”</code></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hello, world.</span><br><span class="line">Hello, world.</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="有名管道-（FIFO）"><a href="#有名管道-（FIFO）" class="headerlink" title="有名管道 （FIFO）"></a>有名管道 （FIFO）</h3><ul>
<li>和无名管道的行为相同，但用于不相关的进程间通信</li>
<li>通过文件系统可访问的基于管道的机制</li>
<li>管道显示为特殊的 FIFO 文件</li>
<li>管道的两端都必须打开（读取和写入）</li>
<li>操作系统在进程之间传递数据而无需执行真正的 I/O</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos007.png" alt=""></p>
<ul>
<li><p>POSIX 提供函数 <code>mkfifo()</code> 来创建可通过文件系统作为特殊文件访问的命名管道</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>pathname: 创建的特殊文件的路径</li>
<li>mode: R/W/X permissions (.e.g. <code>S_IRWXU</code>, <code>S_IRUSR</code>, <code>S_IWUSR</code>,…)<ul>
<li>可从手册页中获取更多信息 ： <code>$ man 2 open</code></li>
</ul>
</li>
</ul>
</li>
<li><p>创建 <code>FIFO</code> 后，我们就可以作为普通文件打开并访问它了</p>
<ul>
<li>在进行 I/O 操作之前，必须将两端打开<ul>
<li>打开 FIFO 以读取普通块，直到其他进程打开相同的 FIFO 进行写为止，反之亦然</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="示例-6a：通过命名管道的外部接口"><a href="#示例-6a：通过命名管道的外部接口" class="headerlink" title="示例 6a：通过命名管道的外部接口"></a>示例 6a：通过命名管道的外部接口</h3><ul>
<li><p><code>fifo_writer.c</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">datatype</span> data;</span><br><span class="line">    <span class="type">char</span> * myfifo = <span class="string">&quot;/tmp/myfifo&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mkfifo</span>(myfifo, S_IRUSR | S_IWUSR) != <span class="number">0</span>)</span><br><span class="line">       <span class="built_in">perror</span>(<span class="string">&quot;Cannot create fifo. Already existing?&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(myfifo, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Cannot open fifo&quot;</span>);</span><br><span class="line">        <span class="built_in">unlink</span>(myfifo);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nb = <span class="built_in">write</span>(fd, &amp;data, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> datatype));</span><br><span class="line">    <span class="keyword">if</span> (nb == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, “Write error\n”);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">unlink</span>(myfifo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fifo_reader.c</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">datatype</span> data;</span><br><span class="line">    <span class="type">char</span> * myfifo = <span class="string">&quot;/tmp/myfifo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(myfifo, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Cannot open fifo&quot;</span>);</span><br><span class="line">        <span class="built_in">unlink</span>(myfifo);<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(fd, &amp;data, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> datatype));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">unlink</span>(myfifo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>The writer</p>
<ul>
<li>创建有名管道(<code>mkfifo</code>)</li>
<li>在读取/写入模式下，将有名管道作为普通文件打开</li>
<li>写入与数据结构大小一样多的字节<ul>
<li>reader 必须处于执行状态（否则数据将发送给任何人）</li>
</ul>
</li>
<li>关闭文件 (<code>close</code>)，然后释放有名管道(<code>unlink</code>)</li>
</ul>
</li>
<li><p>The reader</p>
<ul>
<li>在只读模式下将有名管道作为普通文件打开(open)</li>
<li><code>read()</code> 函数阻塞等待来自 writer 进程的字节</li>
<li>关闭文件 (<code>close</code>)，然后释放有名管道(<code>unlink</code>)</li>
</ul>
</li>
<li><p><code>message-reader.c</code></p>
<ul>
<li>message-writer: 用户从 shell 发送字符串</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> data = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="type">char</span> * myfifo = <span class="string">&quot;/tmp/myfifo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(myfifo, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Cannot open fifo&quot;</span>);</span><br><span class="line">        <span class="built_in">unlink</span>(myfifo);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (data != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">read</span>(fd, &amp;data, <span class="number">1</span>) &amp;&amp; (data != <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%c&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">unlink</span>(myfifo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos008.png" alt=""></p>
</li>
<li><p>message reader</p>
<ul>
<li>有名管道路径作为常规文件 ( <code>open</code> )打开以进行读写<ul>
<li>在读取管道中的数据时需要具有写许可权</li>
</ul>
</li>
<li>执行阻塞 <code>read()</code> 调用以从管道中获取数据</li>
<li>文本字符串的长度是未知的<ul>
<li><code>&#39;#&#39;</code> 用作特殊的 END 字符</li>
</ul>
</li>
<li>终止时关闭( <code>close</code> )并释放管道( <code>unlink</code>) </li>
</ul>
</li>
</ul>
<h3 id="无名管道-vs-有名管道"><a href="#无名管道-vs-有名管道" class="headerlink" title="无名管道 vs 有名管道"></a>无名管道 vs 有名管道</h3><ul>
<li><p>Pros</p>
<ul>
<li>低开销</li>
<li>简单</li>
<li>解决内核空间中的相互访问</li>
</ul>
</li>
<li><p>Cons</p>
<ul>
<li>没有广播</li>
<li>单向</li>
<li>无消息界限，数据作为流进行管理</li>
<li>可扩展性差</li>
</ul>
</li>
</ul>
<hr>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="POSIX-消息队列"><a href="#POSIX-消息队列" class="headerlink" title="POSIX 消息队列"></a>POSIX 消息队列</h3><ul>
<li>适合多个 reader 和多个 writer</li>
<li>优先级驱动的数据交换</li>
<li>消息队列和消息大小由程序员管理</li>
<li>消息队列的状态可以观察到</li>
<li>链接到 POSIX 实时扩展库以进行构建( <code>gcc ... -lrt</code> )</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos009.png" alt=""></p>
<h3 id="消息队列生命周期"><a href="#消息队列生命周期" class="headerlink" title="消息队列生命周期"></a>消息队列生命周期</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>           <span class="comment">/* For O_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>        <span class="comment">/* For mode constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode, <span class="keyword">struct</span> mq_attr *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code> : POSIX 对象名称</li>
<li><code>oflag</code> : 打开标志(<code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>, <code>O_CREAT</code>, <code>O_EXCL</code>, …)</li>
<li><code>mode</code> : R/W/X 权限 (.e.g. <code>S_IRWXU</code>, <code>S_IRUSR</code>, <code>S_IWUSR</code>,…)</li>
<li><code>attr</code> : 属性集(e.g., message size, queue length, etc…)</li>
<li>该函数返回消息队列描述符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_close</span><span class="params">(<span class="type">mqd_t</span> mqdes)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mq_close</code> : 关闭由 <code>mq_open()</code> 返回的描述符所引用的队列</li>
<li><code>mq_link</code> : 删除消息队列并在被所有进程关闭时销毁它</li>
</ul>
<h3 id="消息队列属性"><a href="#消息队列属性" class="headerlink" title="消息队列属性"></a>消息队列属性</h3><ul>
<li><p>属性数据结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mq_attr</span> &#123;</span><br><span class="line">    <span class="type">long</span> mq_flags;       <span class="comment">/* Flags: 0 or O_NONBLOCK */</span> </span><br><span class="line">    <span class="type">long</span> mq_maxmsg;      <span class="comment">/* Max nr of messages on queue */</span></span><br><span class="line">    <span class="type">long</span> mq_msgsize;     <span class="comment">/* Max message size (bytes) */</span></span><br><span class="line">    <span class="type">long</span> mq_curmsgs;     <span class="comment">/* Nr of messages currently in queue */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="keyword">struct</span> mq_attr *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="keyword">struct</span> mq_attr *newattr, <span class="keyword">struct</span> mq_attr *oldattr)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mqdes</code> : 消息队列描述符</li>
<li><code>newattr</code> : 新的属性集</li>
<li><code>oldattr</code> : 先前的属性集</li>
</ul>
</li>
</ul>
<h3 id="消息队列输入-输出"><a href="#消息队列输入-输出" class="headerlink" title="消息队列输入/输出"></a>消息队列输入/输出</h3><ul>
<li><p>发送消息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_send</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> * msg_ptr, <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> msg_prio)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mqdes</code> : 消息队列描述符</li>
<li><code>msg_ptr</code> : 指向要发送的消息的指针</li>
<li><code>msg_len</code> : 消息长度</li>
<li><code>msg_prio</code> : 非负优先级值(in POSIX: 0..31)</li>
</ul>
</li>
<li><p>消息按优先级从高到低的顺序排队</p>
<ul>
<li>优先级相同的消息 —— 新消息放置在旧消息之后</li>
</ul>
</li>
<li><p>队列满 —— 函数调用块</p>
<ul>
<li>如果在属性中将 <code>O_NONBLOCK</code> 指定为标志，则返回错误</li>
</ul>
</li>
<li><p>接收消息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_receive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> * msg_ptr, <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> * msg_prio)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mqdes</code> : 消息队列描述符</li>
<li><code>msg_ptr</code> : 消息缓冲区</li>
<li><code>msg_len</code> : 消息缓冲区长度</li>
<li><code>msg_prio</code> : 与接收到的消息相关联的非负优先级值(in POSIX: 0..31)</li>
<li>返回接收到的消息中的字节数，如果出错则返回 <code>-1</code></li>
</ul>
</li>
<li><p>函数调用将被阻塞，直到队列中有消息可用为止</p>
<ul>
<li>如果在属性中将 <code>O_NONBLOCK</code> 指定为标志，则返回错误</li>
</ul>
</li>
</ul>
<h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li>API 的简单性</li>
<li>消息打包</li>
<li>数据可以具有不同的优先级</li>
<li>解决内核空间中的相互访问</li>
<li>可以利用通知机制（未见）</li>
</ul>
<h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><ul>
<li>与管道相比性能低下<ul>
<li>发送消息实际上涉及写入文件</li>
</ul>
</li>
<li>单向</li>
</ul>
<hr>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><ul>
<li>Linux / UNIX OS 中的共享内存基于内存映射</li>
<li>一个内存段可以映射到多个进程的地址空间中</li>
<li>POSIX 实现：链接到实时扩展(<code>gcc ... -lrt</code>)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos010.png" alt=""></p>
<ul>
<li><p>通过名称引用打开/创建共享内存对象</p>
<ul>
<li>提供名称的特殊文件出现在 <code>“/dev/shm/&lt;name&gt;”</code> 中<ul>
<li>这是 POSIX 对象，可以由不相关的进程使用的句柄</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>        <span class="comment">/* For mode constants */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>           <span class="comment">/* For O_* constants */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code> : POSIX 对象名称</li>
<li><code>oflag</code> : 打开标志 (<code>O_RDONLY</code>, <code>O_RDWR</code>, <code>O_CREAT</code>, <code>O_EXCL</code>, <code>O_TRUNC</code>)</li>
<li><code>mode</code> : R/W/X 权限 (.e.g. <code>S_IRWXU</code>, <code>S_IRUSR</code>, <code>S_IWUSR</code>,…)</li>
<li>该函数返回一个文件描述符</li>
</ul>
</li>
<li><p>分配内存对象后，在实际分配内存区域之前，我们必须指定特殊文件的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>        <span class="comment">/* For mode constants */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>path/fd : 文件路径或文件描述符</li>
<li><p>length : 特殊文件的大小</p>
</li>
<li><p>由于 <code>shm_open(...)</code> 返回文件描述符，因此我们将使用 <code>ftruncate(...)</code></p>
</li>
</ul>
</li>
<li><p>调用进程的（虚拟）地址空间中的新映射</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>addr</code> : 起始地址。如果为 <code>NULL</code>，Linux 内核将选择</li>
<li><code>length</code> : 映射的内容使用 <code>length</code> 字节初始化，在 “文件映射” 的情况下，它从引用文件 <code>fd</code> 中的 <code>offset</code> 开始</li>
<li><code>prot</code> : 映射的内存保护，即进程可以做什么<ul>
<li><code>PROT_EXEC</code>, <code>PROT_READ</code>, <code>PROT_WRITE</code>, <code>PROT_NONE</code></li>
</ul>
</li>
<li><code>flags</code> : 来自其他进程的更新可见性<ul>
<li><code>MAP_SHARED</code> : 映射的内存是共享的。更新对其他进程可见，并通过基础文件进行</li>
<li><code>MAP_PRIVATE</code> : 私有写时复制。更新不提供给其他人，也不通过基础文件进行</li>
</ul>
</li>
<li>它返回一个指向映射区域的指针</li>
</ul>
</li>
<li><p>取消映射区域</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>取消给定范围内映射的所有内存页<ul>
<li>addr 必须是内存页面大小的倍数(在 Linux 中通常为 4K )</li>
</ul>
</li>
<li>执行后，对该区域的后续访问将生成 <code>SIGSEV</code></li>
</ul>
</li>
<li><p>释放共享内存对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除 POSIX 对象</li>
<li>一旦所有进程都取消了对象的映射，便取消分配并销毁关联内存区域的内容</li>
</ul>
</li>
</ul>
<h3 id="示例-7：简单的共享内存映射"><a href="#示例-7：简单的共享内存映射" class="headerlink" title="示例 7：简单的共享内存映射"></a>示例 7：简单的共享内存映射</h3><ul>
<li><p><code>posix-shm-server.c</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * shm_name  = <span class="string">&quot;/AOS&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * message[] = &#123;<span class="string">&quot;This &quot;</span>,<span class="string">&quot;is &quot;</span>,<span class="string">&quot;about &quot;</span>,<span class="string">&quot;shared &quot;</span>,<span class="string">&quot;memory&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, shm_fd;</span><br><span class="line">    <span class="type">void</span> * ptr;</span><br><span class="line">    shm_fd = <span class="built_in">shm_open</span>(shm_name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == ­<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Shared memory segment failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(­<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ftruncate</span>(shm_fd, <span class="built_in">sizeof</span>(message));</span><br><span class="line">    ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Map failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ­<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Write into the memory segment */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(*message); ++i) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(ptr, <span class="string">&quot;%s&quot;</span>, message[i]);</span><br><span class="line">        ptr += <span class="built_in">strlen</span>(message[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mummap</span>(ptr, SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器创建由 <code>“/AOS”</code> 引用的共享内存</li>
<li>服务器将一些数据（字符串）写入内存段</li>
<li>每次写入 char 字符串后，指针 ptr 都会增加</li>
</ul>
</li>
<li><p><code>posix-shm-client.c</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * shm_name  = <span class="string">&quot;/AOS&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">int</span> i, shm_fd;</span><br><span class="line">    <span class="type">void</span> * ptr;</span><br><span class="line">    shm_fd = <span class="built_in">shm_open</span>(shm_name, O_RDONLY, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == ­<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Shared memory segment failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(-­<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = <span class="built_in">mmap</span>(<span class="number">0</span>, SIZE, PROT_READ, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Map failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span> *) ptr);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shm_unlink</span>(shm_name) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error removing %s\n&quot;</span>, shm_name);</span><br><span class="line">        <span class="built_in">exit</span>(­<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端以只读模式打开内存段 “AOS”</li>
<li>客户端以只读模式映射内存段</li>
<li>客户端将内存段内容写入控制台</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos011.png" alt=""></p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><ul>
<li>内存映射使我们能够在逻辑上将部分或全部命名二进制文件插入进程地址空间</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/blog/cpp/linux/aos012.png" alt=""></p>
<h3 id="示例-8：简单的-I-O-映射"><a href="#示例-8：简单的-I-O-映射" class="headerlink" title="示例 8：简单的 I/O 映射"></a>示例 8：简单的 I/O 映射</h3><ul>
<li>通过命令行(<code>argv[1]</code>)传递的文件被打开，然后使用 <code>mmap()</code> 系统调用映射内存</li>
<li><code>mmap()</code> 需要地址，区域大小(文件长度)，权限，范围标志，文件描述符和偏移量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> * p;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    p = <span class="built_in">mmap</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>), PROT_READ | PROT_WRITE , MAP_SHARED, fd, <span class="number">0</span>); </span><br><span class="line">    (*p)++;</span><br><span class="line">    <span class="built_in">munmap</span>(p, <span class="built_in">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line">    <span class="built_in">close</span> (fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros"></a>Pros</h3><ul>
<li>可以减少内存使用<ul>
<li>可以映射和共享大的数据结构，以将相同的输入集提供给多个进程</li>
</ul>
</li>
<li>I/O映射能非常有效<ul>
<li>内存访问，而不是 I/O 读/写</li>
<li>仅当内容已修改时，才由 OS 回写到内存页</li>
<li>使用指针算法而不是 <code>“lseek”</code> 执行文件查找</li>
</ul>
</li>
</ul>
<h3 id="Cons-1"><a href="#Cons-1" class="headerlink" title="Cons"></a>Cons</h3><ul>
<li>具有内存页大小的 Linux 映射内存<ul>
<li>Linux 内存页大小通常为 4KB</li>
<li>使用内存映射来映射大文件或共享大数据结构</li>
</ul>
</li>
<li>可能导致内存碎片<ul>
<li>特别是在 32 位架构上</li>
</ul>
</li>
<li>多个小的映射可能操作系统开销大</li>
</ul>
<hr>
<h2 id="同步-1"><a href="#同步-1" class="headerlink" title="同步"></a>同步</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>多任务应用程序中的并发性可能会引入竞态条件，我们需要保护共享资源</li>
<li>信号量通常是由 OS 内核管理的系统对象</li>
<li>信号量充当计数器，我们可以通过执行以下两个操作来操纵它们：<code>increment (wait)</code> 和 <code>decrement (post)</code></li>
<li>如果计数器值 &gt; 0，则 <code>wait</code> 计数器递减并允许任务进入临界区</li>
<li>如果计数器值 = 0，则 <code>wait</code> 将阻塞任务在等待列表中</li>
<li><code>post</code> 增加计数器值<ul>
<li>如果先前的值为 0，则从等待列表中唤醒任务</li>
</ul>
</li>
<li>二进制信号量(<code>value</code> = <code>0</code> or <code>1</code>)实现相同的互斥行为</li>
<li>不是二进制信号量（值 <code>0..n</code>）适用于保护对资源池的访问</li>
</ul>
<h3 id="命名信号量的打开-创建和释放"><a href="#命名信号量的打开-创建和释放" class="headerlink" title="命名信号量的打开/创建和释放"></a>命名信号量的打开/创建和释放</h3><ul>
<li><p>函数 <code>sem_open(...)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">sem_t</span> * <span class="title">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">sem_t</span> * <span class="title">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflags, <span class="type">mode_t</span> mode, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code> : POSIX（信号量）对象名称(under <code>“/dev/shm/sem.&lt;name&gt;”</code>)</li>
<li><code>oflag</code> : 打开标志(<code>O_CREAT</code>, <code>O_EXCL</code>)</li>
<li><code>mode</code> : <code>R/W/X</code> 权限 (.e.g. <code>S_IRWXU</code>, <code>S_IRUSR</code>, <code>S_IWUSR</code>,…)</li>
<li><code>value</code> : 初始值</li>
<li>它将返回新信号量的地址或出现错误时返回 <code>SEM_FAILED</code></li>
</ul>
</li>
<li><p>释放指定的信号量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="未命名的信号量初始化和销毁"><a href="#未命名的信号量初始化和销毁" class="headerlink" title="未命名的信号量初始化和销毁"></a>未命名的信号量初始化和销毁</h3><ul>
<li><p>函数 <code>sem_init(...)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>此函数可用于多进程或多线程应用程序</li>
<li><code>sem</code> : 初始化信号量数据结构</li>
<li><code>pshared</code> :如果为 <code>0</code>，则线程之间共享，如果不是 <code>0</code>，则进程之间共享</li>
<li><code>value</code> : 初始值</li>
<li>该函数返回 <code>0</code> 表示成功，返回 <code>-1</code> 表示错误</li>
</ul>
</li>
<li><p>完成后可以销毁已初始化的未命名信号量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="加锁和解锁函数"><a href="#加锁和解锁函数" class="headerlink" title="加锁和解锁函数"></a>加锁和解锁函数</h3><ul>
<li><p>减量/加锁函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sem</code> : 递减（加锁）的信号量的数据结构</li>
<li><code>timeout</code> : 设置 <code>value == 0</code> 时调用应被阻塞的时间限制</li>
<li><code>try_wait(...)</code> 在 <code>value == 0</code>，则返回错误而不是阻塞</li>
</ul>
</li>
<li><p>增量/解锁函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有函数成功时返回 <code>0</code>，错误时返回 <code>-1</code></p>
</li>
</ul>
<h3 id="示例-9：对共享内存使用信号量"><a href="#示例-9：对共享内存使用信号量" class="headerlink" title="示例 9：对共享内存使用信号量"></a>示例 9：对共享内存使用信号量</h3><ul>
<li><code>posix-shm-sem-writer.c</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMOBJ_PATH  <span class="string">&quot;/shm_AOS&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_PATH     <span class="string">&quot;/sem_AOS&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">shared_data</span> &#123;</span><br><span class="line">    <span class="type">char</span> var1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> shared_seg_size = (<span class="number">1</span> * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> shared_data));</span><br><span class="line">    <span class="type">int</span> shmfd  = <span class="built_in">shm_open</span>(SHMOBJ_PATH, O_CREAT | O_RDWR, S_IRWU | S_IRWG);</span><br><span class="line">    <span class="built_in">ftruncate</span>(shmfd, shared_seg_size);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">shared_data</span> * shared_msg = (<span class="keyword">struct</span> shared_data *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, shared_seg_size, PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">sem_t</span> * sem_id = <span class="built_in">sem_open</span>(SEM_PATH, O_CREAT, S_IRUSR | S_IWUSR, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">shared_data</span> out_msg = &#123; “John”, <span class="number">23</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_wait</span>(sem_id);</span><br><span class="line">    <span class="comment">/* Update shared data */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(shared_msg, &amp;out_msg, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> shared_data);</span><br><span class="line">    <span class="built_in">sem_post</span>(sem_id);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shm_unlink</span>(SHMOBJ_PATH);</span><br><span class="line">    <span class="built_in">sem_unlink</span>(SEM_PATH);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>写进程</p>
<ul>
<li>映射一个内存区域</li>
<li>创建一个命名信号量并将其初始化为 <code>1</code> ( <code>sem_open</code> )</li>
<li>减少信号量计数器以获得对共享内存区域的独占访问 ( <code>sem_wait</code> )</li>
<li>写入内存区域 ( <code>memcpy</code> )</li>
<li>增加信号量计数器并释放对内存区域的访问 ( <code>sem_post</code> )</li>
<li>释放共享内存区域 ( <code>shm_unlink</code> )</li>
<li>关闭并释放信号量对象 ( <code>sem_unlink</code> )</li>
</ul>
</li>
<li><p><code>posix-shm-sem-reader.c</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMOBJ_PATH  <span class="string">&quot;/shm_AOS&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_PATH     <span class="string">&quot;/sem_AOS&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">shared_data</span> &#123;</span><br><span class="line">    <span class="type">char</span> var1[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> shared_seg_size = (<span class="number">1</span> * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> shared_data));</span><br><span class="line">    <span class="type">int</span> shmfd  = <span class="built_in">shm_open</span>(SHMOBJ_PATH, O_RDONLY, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">shared_data</span> * shared_msg = (<span class="keyword">struct</span> shared_data *) <span class="built_in">mmap</span>(<span class="literal">NULL</span>, shared_seg_size, PROT_READ, MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">sem_t</span> * sem_id = <span class="built_in">sem_open</span>(SEM_PATH, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">shared_data</span> in_msg;</span><br><span class="line">    <span class="built_in">sem_wait</span>(sem_id);</span><br><span class="line">    <span class="comment">/* Update shared data */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;in_msg, shared_msg, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> shared_data);</span><br><span class="line">    <span class="built_in">sem_post</span>(sem_id);</span><br><span class="line">    <span class="comment">/* Process data... */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">shm_unlink</span>(SHMOBJ_PATH);</span><br><span class="line">    <span class="built_in">sem_unlink</span>(SEM_PATH);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读进程<ul>
<li>映射一个内存区域 (read-only access)</li>
<li>打开已初始化的信号量对象 ( <code>sem_open</code> )</li>
<li>减少信号量计数器以获得对共享内存区域的独占访问 ( <code>sem_wait</code> )</li>
<li>将内存区域中的数据复制到本地变量 ( <code>memcpy</code> )</li>
<li>增加信号量计数器并释放对内存区域的访问 ( <code>sem_post</code> )</li>
<li>处理数据</li>
<li>释放共享内存区域 ( <code>shm_unlink</code> )</li>
<li>关闭并释放信号量对象 ( <code>sem_unlink</code> )</li>
</ul>
</li>
</ul>
<hr>
<h2 id="选择-IPC-机制"><a href="#选择-IPC-机制" class="headerlink" title="选择 IPC 机制"></a>选择 IPC 机制</h2><h3 id="因素"><a href="#因素" class="headerlink" title="因素"></a>因素</h3><ul>
<li>“IPC 性能是一个复杂且多元的问题”</li>
<li>机器架构</li>
<li>数据大小和数据位置</li>
<li>虚拟化的存在</li>
<li>原语实现</li>
<li>当前系统工作量</li>
</ul>
<h3 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h3><ul>
<li>剑桥大学开发了 ipc-bench 基准，并提供了结果的公共数据库<ul>
<li><a target="_blank" rel="noopener" href="http://www.cl.cam.ac.uk/research/srg/netos/projects/ipc-bench/">http://www.cl.cam.ac.uk/research/srg/netos/projects/ipc-bench/</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.safaribooksonline.com/library/view/linux-system-programming/0596009585/ch04s03.html">https://www.safaribooksonline.com/library/view/linux-system-programming/0596009585/ch04s03.html</a></li>
<li><a target="_blank" rel="noopener" href="http://www.linuxprogrammingblog.com/all-about-linux-signals?page=3">http://www.linuxprogrammingblog.com/all-about-linux-signals?page=3</a></li>
<li><a target="_blank" rel="noopener" href="https://www.softprayog.in/programming/posix-semaphores">https://www.softprayog.in/programming/posix-semaphores</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://busyboxs.github.io">Busyboxs</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://busyboxs.github.io/blogs/3da05f76/">https://busyboxs.github.io/blogs/3da05f76/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://busyboxs.github.io" target="_blank">Busyboxs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blogs/db6815e3/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/cpp.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 中的 const 关键字</div></div></a></div><div class="next-post pull-right"><a href="/blogs/b5f5e1a5/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/cpp.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">僵尸进程及其预防</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blogs/cb803aa6/" title="(简单调用篇 03) 动物识别 - C++ 简单调用"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/baiduAI.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-07</div><div class="title">(简单调用篇 03) 动物识别 - C++ 简单调用</div></div></a></div><div><a href="/blogs/3f2fcf2e/" title="(基础篇 04) C++ base64 编解码原理及实现"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/baiduAI.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-25</div><div class="title">(基础篇 04) C++ base64 编解码原理及实现</div></div></a></div><div><a href="/blogs/dea770b9/" title="（基础篇 01）在控制台创建对应的应用"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/baiduAI.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-25</div><div class="title">（基础篇 01）在控制台创建对应的应用</div></div></a></div><div><a href="/blogs/6956883f/" title="(简单调用篇 09) 货币识别 - C++ 简单调用"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/baiduAI.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-07</div><div class="title">(简单调用篇 09) 货币识别 - C++ 简单调用</div></div></a></div><div><a href="/blogs/49f400d2/" title="（基础篇 03）C++ 获取 access token"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/baiduAI.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-25</div><div class="title">（基础篇 03）C++ 获取 access token</div></div></a></div><div><a href="/blogs/957d8cb8/" title="(简单调用篇 07) 菜品识别 - C++ 简单调用"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/baiduAI.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-07</div><div class="title">(简单调用篇 07) 菜品识别 - C++ 简单调用</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">多进程编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.</span> <span class="toc-text">进程间通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-1"><span class="toc-number">2.</span> <span class="toc-text">多进程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">为什么要多进程编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1-%EF%BC%9Afork-%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">实例 1 ：fork 一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2a"><span class="toc-number">2.3.</span> <span class="toc-text">实例 2a</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">2.4.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2b-%EF%BC%9A%E4%BB%A5%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F-fork-%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">实例 2b ：以同步方式 fork 一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">生成执行程序进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-number">2.8.</span> <span class="toc-text">例子 3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-1"><span class="toc-number">3.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">3.1.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POSIX-vs-System-V"><span class="toc-number">3.2.</span> <span class="toc-text">POSIX vs System V</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">4.2.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">同步化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84-POSIX-%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.4.</span> <span class="toc-text">最常见的 POSIX 信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%B3%A8%E5%86%8C"><span class="toc-number">4.5.</span> <span class="toc-text">信号处理程序注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-4%EF%BC%9A%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">例子 4：用户定义信号处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.7.</span> <span class="toc-text">发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-4b%EF%BC%9A%E4%BF%A1%E5%8F%B7%E5%8F%91%E9%80%81%E5%99%A8%E7%A8%8B%E5%BA%8F%EF%BC%88SIGUSR1%EF%BC%89"><span class="toc-number">4.8.</span> <span class="toc-text">例子 4b：信号发送器程序（SIGUSR1）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">4.9.</span> <span class="toc-text">信号信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B-4c%EF%BC%9A%E8%AE%BF%E9%97%AE%E4%BF%A1%E5%8F%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">4.10.</span> <span class="toc-text">例 4c：访问信号信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.11.</span> <span class="toc-text">阻塞信号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">5.</span> <span class="toc-text">管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">5.1.</span> <span class="toc-text">无名管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B5%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%BA%E4%BA%8E%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">5.2.</span> <span class="toc-text">例5：简单的基于无名管道的消息传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93-%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">有名管道 （FIFO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6a%EF%BC%9A%E9%80%9A%E8%BF%87%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.</span> <span class="toc-text">示例 6a：通过命名管道的外部接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93-vs-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">5.5.</span> <span class="toc-text">无名管道 vs 有名管道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#POSIX-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.1.</span> <span class="toc-text">POSIX 消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.2.</span> <span class="toc-text">消息队列生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B1%9E%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">消息队列属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-number">6.4.</span> <span class="toc-text">消息队列输入&#x2F;输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pros"><span class="toc-number">6.5.</span> <span class="toc-text">Pros</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cons"><span class="toc-number">6.6.</span> <span class="toc-text">Cons</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">7.</span> <span class="toc-text">共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">7.1.</span> <span class="toc-text">内存映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-7%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">7.2.</span> <span class="toc-text">示例 7：简单的共享内存映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">7.3.</span> <span class="toc-text">内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-8%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84-I-O-%E6%98%A0%E5%B0%84"><span class="toc-number">7.4.</span> <span class="toc-text">示例 8：简单的 I&#x2F;O 映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pros-1"><span class="toc-number">7.5.</span> <span class="toc-text">Pros</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cons-1"><span class="toc-number">7.6.</span> <span class="toc-text">Cons</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-1"><span class="toc-number">8.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">8.1.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%89%93%E5%BC%80-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-number">8.2.</span> <span class="toc-text">命名信号量的打开&#x2F;创建和释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%91%BD%E5%90%8D%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">8.3.</span> <span class="toc-text">未命名的信号量初始化和销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E5%92%8C%E8%A7%A3%E9%94%81%E5%87%BD%E6%95%B0"><span class="toc-number">8.4.</span> <span class="toc-text">加锁和解锁函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-9%EF%BC%9A%E5%AF%B9%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">8.5.</span> <span class="toc-text">示例 9：对共享内存使用信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-IPC-%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">选择 IPC 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E7%B4%A0"><span class="toc-number">9.1.</span> <span class="toc-text">因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Benchmarks"><span class="toc-number">9.2.</span> <span class="toc-text">Benchmarks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90"><span class="toc-number">10.</span> <span class="toc-text">资源</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/img/archive_img.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By Busyboxs</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">❤🦋Stay foolish. Stay hungry.🦋❤</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="爱你哟,好好学习，天天向上,Stay hungry. Stay foolish.,✨✨✨,🎈🎈🎈,🎮🎮,♥♥♥♥,🏐🏐,🪂🪂" data-fontsize="10px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>