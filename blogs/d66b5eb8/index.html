<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>argparse - 用于命令行选项，参数和子命令的解析器 | Busyboxs</title><meta name="keywords" content="python"><meta name="author" content="Busyboxs"><meta name="copyright" content="Busyboxs"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="argparse模块可以轻松编写用户友好的命令行界面。该程序定义了它需要的参数，argparse将找出如何解析sys.argv中的那些参数。argparse模块还会自动生成 help (帮助)和 usage(用法) 消息，并在用户给出程序无效参数时发出错误。 Example以下代码是一个Python程序，它接受一个整数列表并求出总和或最大值 import argparseparser &#x3D; argp">
<meta property="og:type" content="article">
<meta property="og:title" content="argparse - 用于命令行选项，参数和子命令的解析器">
<meta property="og:url" content="https://busyboxs.github.io/blogs/d66b5eb8/index.html">
<meta property="og:site_name" content="Busyboxs">
<meta property="og:description" content="argparse模块可以轻松编写用户友好的命令行界面。该程序定义了它需要的参数，argparse将找出如何解析sys.argv中的那些参数。argparse模块还会自动生成 help (帮助)和 usage(用法) 消息，并在用户给出程序无效参数时发出错误。 Example以下代码是一个Python程序，它接受一个整数列表并求出总和或最大值 import argparseparser &#x3D; argp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/python.png">
<meta property="article:published_time" content="2019-01-24T11:52:22.000Z">
<meta property="article:modified_time" content="2019-08-13T02:39:21.237Z">
<meta property="article:author" content="Busyboxs">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/python.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://busyboxs.github.io/blogs/d66b5eb8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google_site_verification" content="FwkuU16DW0uUtLvBlI63aK9-eCBhC55pVQMscORY34M"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0737f86b9c26e7c4269a4dec38cea0c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-158970947-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-158970947-1');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lacquer&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'argparse - 用于命令行选项，参数和子命令的解析器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2019-08-13 10:39:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">90</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/img/archive_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Busyboxs</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">argparse - 用于命令行选项，参数和子命令的解析器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-01-24T11:52:22.000Z" title="发表于 2019-01-24 19:52:22">2019-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2019-08-13T02:39:21.237Z" title="更新于 2019-08-13 10:39:21">2019-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="argparse - 用于命令行选项，参数和子命令的解析器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>argparse模块可以轻松编写用户友好的命令行界面。该程序定义了它需要的参数，argparse将找出如何解析sys.argv中的那些参数。argparse模块还会自动生成 help (帮助)和 usage(用法) 消息，并在用户给出程序无效参数时发出错误。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>以下代码是一个Python程序，它接受一个整数列表并求出总和或最大值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Process some integers.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;integers&#x27;</span>, metavar=<span class="string">&#x27;N&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;an integer for the accumulator&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--sum&#x27;</span>, dest=<span class="string">&#x27;accumulate&#x27;</span>, action=<span class="string">&#x27;store_const&#x27;</span>,</span><br><span class="line">                    const=<span class="built_in">sum</span>, default=<span class="built_in">max</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;sum the integers (default: find the max)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="built_in">print</span> args.accumulate(args.integers)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>假设上面的Python代码被保存到名为 prog.py 的文件中，它可以在命令行运行并提供有用的帮助信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python prog.py -h</span><br><span class="line">usage: prog.py [-h] [--<span class="built_in">sum</span>] N [N ...]</span><br><span class="line"></span><br><span class="line">Process some integers.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> N           an <span class="built_in">integer</span> <span class="keyword">for</span> the accumulator</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line"> --<span class="built_in">sum</span>       <span class="built_in">sum</span> the integers (default: find the max)</span><br></pre></td></tr></table></figure>
<p>当使用适当的参数运行时，它会输出命令行整数的总和或最大值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python prog.py 1 2 3 4</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">$ python prog.py 1 2 3 4 --sum</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>如果传入无效参数，它将发出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python prog.py a b c</span><br><span class="line">usage: prog.py [-h] [--sum] N [N ...]</span><br><span class="line">prog.py: error: argument N: invalid int value: &#x27;a&#x27;</span><br></pre></td></tr></table></figure>
<p>以下部分将引导您完成此示例。</p>
<h3 id="Creating-a-parser"><a href="#Creating-a-parser" class="headerlink" title="Creating a parser"></a>Creating a parser</h3><p>使用argparse的第一步是创建一个ArgumentParser对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Process some integers.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>ArgumentParser对象将包含将命令行解析为Python数据类型所需的所有信息。</p>
<h3 id="Adding-arguments"><a href="#Adding-arguments" class="headerlink" title="Adding arguments"></a>Adding arguments</h3><p>通过调用<code>add_argument()</code>法完成关于程序参数信息的 ArgumentParser 填充。通常，这些调用告诉ArgumentParser如何在命令行上获取字符串并将它们转换为对象。这个信息在<code>parse_args()</code>调用时被存储和使用。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;integers&#x27;</span>, metavar=<span class="string">&#x27;N&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, nargs=<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line">					<span class="built_in">help</span>=<span class="string">&#x27;an integer for the accumulator&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--sum&#x27;</span>, dest=<span class="string">&#x27;accumulate&#x27;</span>, action=<span class="string">&#x27;store_const&#x27;</span>,</span><br><span class="line">                    const=<span class="built_in">sum</span>, default=<span class="built_in">max</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;sum the integers (default: find the max)&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>稍后，调用<code>parse_args()</code>返回一个具有两个属性(integers, accumulate)的对象。integers 属性将是一个或多个整数的列表，如果在命令行指定了<code>--sum</code>，accumulate属性将是<code>sum()</code>函数，如果不指定则为<code>max()</code>函数。</p>
<h3 id="Parsing-arguments"><a href="#Parsing-arguments" class="headerlink" title="Parsing arguments"></a>Parsing arguments</h3><p>ArgumentParser通过<code>parse_args()</code>法解析参数。这将检查命令行，将每个参数转换为适当的类型，然后调用相应的操作。在大多数情况下，这意味着一个简单的 Namespace 对象将由从命令行解析出来的属性构建而成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.parse_args([<span class="string">&#x27;--sum&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;-1&#x27;</span>, <span class="string">&#x27;42&#x27;</span>])</span><br><span class="line">Namespace(accumulate=&lt;built-<span class="keyword">in</span> function <span class="built_in">sum</span>&gt;, integers=[<span class="number">7</span>, -<span class="number">1</span>, <span class="number">42</span>])</span><br></pre></td></tr></table></figure>
<p>在脚本中，<code>parse_args()</code>不带参数被调用，而 ArgumentParser 将自动从 sys.argv 中确定命令行参数。</p>
<h2 id="ArgumentParser-objects"><a href="#ArgumentParser-objects" class="headerlink" title="ArgumentParser objects"></a>ArgumentParser objects</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class argparse.ArgumentParser（prog = None，usage = None，description = None，epilog = None，parents = []，formatter_class = argparse.HelpFormatter，prefix_chars =&#x27; - &#x27;，fromfile_prefix_chars = None，argument_default = None，conflict_handler =&#x27;error&#x27;，add_help = True ）</span><br></pre></td></tr></table></figure>
<p>创建一个新的ArgumentParser对象。所有参数都应该作为关键字参数传递。下面的每个参数都有自己的更详细的描述，</p>
<ul>
<li><code>prog</code> - The name of the program (default: sys.argv[0])</li>
<li><code>usage</code> - The string describing the program usage (default: generated from arguments added to parser)</li>
<li><code>description</code> - Text to display before the argument help (default: none)</li>
<li><code>epilog</code> - Text to display after the argument help (default: none)</li>
<li><code>parents</code> - A list of ArgumentParser objects whose arguments should also be included</li>
<li><code>formatter_class</code> - A class for customizing the help output</li>
<li><code>prefix_chars</code> - The set of characters that prefix optional arguments (default: ‘-‘)</li>
<li><code>fromfile_prefix_chars</code> - The set of characters that prefix files from which additional arguments should be read (default: None)</li>
<li><code>argument_default</code>- The global default value for arguments (default: None)</li>
<li><code>conflict_handler</code> - The strategy for resolving conflicting optionals (usually unnecessary)</li>
<li><code>add_help</code> - Add a -h/—help option to the parser (default: True)</li>
</ul>
<p>以下部分描述如何使用每个这些。</p>
<h3 id="prog"><a href="#prog" class="headerlink" title="prog"></a>prog</h3><p>默认情况下，ArgumentParser对象用于<code>sys.argv[0]</code>确定如何在帮助消息中显示程序的名称。这个默认值几乎总是可取的，因为它会使帮助消息与命令行上的程序调用方式相匹配。例如，考虑 myprogram.py 使用以下代码命名的文件 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--foo&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;foo help&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>
<p>该程序的帮助将显示myprogram.py为程序名称（不管程序从何处被调用）：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span> python myprogram.py --help</span><br><span class="line">usage: myprogram.py [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo FOO   foo help</span><br><span class="line"><span class="built_in">$</span> cd ..</span><br><span class="line"><span class="built_in">$</span> python subdir/myprogram.py --help</span><br><span class="line">usage: myprogram.py [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo FOO   foo help</span><br></pre></td></tr></table></figure>
<p>要更改此默认行为，可以使用以下<code>prog=</code>参数提供另一个值 给 ArgumentParser：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">&#x27;myprogram&#x27;</span>)</span><br><span class="line">parser.print_help()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usage: myprogram [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br></pre></td></tr></table></figure>
<p>请注意，程序名称（无论从参数确定<code>sys.argv[0]</code>还是从 <code>prog=</code>参数确定）都可用于使用<code>%(prog)s</code>格式说明符来帮助消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;myprogram&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, help=&#x27;foo of the %(prog)s program&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: myprogram [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo FOO   foo of the myprogram program</span><br></pre></td></tr></table></figure>
<h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><p>默认情况下，ArgumentParser根据它包含的参数计算使用情况消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, nargs=&#x27;?&#x27;, help=&#x27;foo help&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, nargs=&#x27;+&#x27;, help=&#x27;bar help&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: PROG [-h] [--foo [FOO]] bar [bar ...]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar          bar help</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help   show this help message and exit</span><br><span class="line"> --foo [FOO]  foo help</span><br></pre></td></tr></table></figure>
<p>默认消息可以用<code>usage=</code>关键字参数覆盖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;, usage=&#x27;%(prog)s [options]&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, nargs=&#x27;?&#x27;, help=&#x27;foo help&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, nargs=&#x27;+&#x27;, help=&#x27;bar help&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: PROG [options]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar          bar help</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help   show this help message and exit</span><br><span class="line"> --foo [FOO]  foo help</span><br></pre></td></tr></table></figure>
<p>该<code>%(prog)s</code>格式说明可填写程序名称到您的使用情况的信息。</p>
<h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>大多数对ArgumentParser构造函数的调用将使用 <code>description=</code>关键字参数。这个观点简要介绍了程序的功能和工作原理。在帮助消息中，说明显示在命令行用法字符串和各种参数的帮助消息之间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(description=&#x27;A foo that bars&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: argparse.py [-h]</span><br><span class="line"></span><br><span class="line">A foo that bars</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br></pre></td></tr></table></figure>
<p>默认情况下，描述将被行包裹，以便它符合给定的空间。要改变这种行为，请参阅<code>formatter_class</code>参数。</p>
<h3 id="epilog"><a href="#epilog" class="headerlink" title="epilog"></a>epilog</h3><p>一些程序喜欢在参数描述之后显示程序的附加描述。这样的文本可以使用<code>epilog=</code>参数来指定 ArgumentParser：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(</span><br><span class="line">...     description=&#x27;A foo that bars&#x27;,</span><br><span class="line">...     epilog=&quot;And that&#x27;s how you&#x27;d foo a bar&quot;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: argparse.py [-h]</span><br><span class="line"></span><br><span class="line">A foo that bars</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"></span><br><span class="line">And that&#x27;s how you&#x27;d foo a bar</span><br></pre></td></tr></table></figure>
<p>与<code>description</code>参数一样，<code>epilog=</code>文本在默认情况下是行包装的，但此行为可以使用<code>formatter_class</code>参数进行调整ArgumentParser。</p>
<h3 id="parents"><a href="#parents" class="headerlink" title="parents"></a>parents</h3><p>有时，几个解析器共享一组通用参数。 可以使用具有所有共享参数并传递给<code>parents=</code>参数的单个解析器，而不是重复这些参数的定义ArgumentParser。该<code>parents=</code>参数获取ArgumentParser 对象列表，收集所有位置和可选操作，并将这些操作添加到ArgumentParser正在构建的对象中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parent_parser = argparse.ArgumentParser(add_help=False)</span><br><span class="line">&gt;&gt;&gt; parent_parser.add_argument(&#x27;--parent&#x27;, type=int)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; foo_parser = argparse.ArgumentParser(parents=[parent_parser])</span><br><span class="line">&gt;&gt;&gt; foo_parser.add_argument(&#x27;foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; foo_parser.parse_args([&#x27;--parent&#x27;, &#x27;2&#x27;, &#x27;XXX&#x27;])</span><br><span class="line">Namespace(foo=&#x27;XXX&#x27;, parent=2)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; bar_parser = argparse.ArgumentParser(parents=[parent_parser])</span><br><span class="line">&gt;&gt;&gt; bar_parser.add_argument(&#x27;--bar&#x27;)</span><br><span class="line">&gt;&gt;&gt; bar_parser.parse_args([&#x27;--bar&#x27;, &#x27;YYY&#x27;])</span><br><span class="line">Namespace(bar=&#x27;YYY&#x27;, parent=None)</span><br></pre></td></tr></table></figure>
<p>请注意，大多数父解析器将指定<code>add_help=False</code>。否则， ArgumentParser将会看到两个<code>-h/--help</code>选项（一个在父项中，一个在子项中）并引发错误。</p>
<blockquote>
<p>注意 在传递它们之前，您必须完全初始化解析器<code>parents=</code>。如果在子解析器之后更改父解析器，那些更改将不会反映到子解析器中。</p>
</blockquote>
<h3 id="formatter-class"><a href="#formatter-class" class="headerlink" title="formatter_class"></a>formatter_class</h3><p>ArgumentParser对象允许通过指定备用格式类来自定义帮助格式。目前，有三个这样的类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class argparse.RawDescriptionHelpFormatter</span><br><span class="line">class argparse.RawTextHelpFormatter</span><br><span class="line">class argparse.ArgumentDefaultsHelpFormatter</span><br></pre></td></tr></table></figure>
<p>前两个允许更多的控制如何显示文本描述，而最后一个自动添加有关参数默认值的信息。</p>
<p>默认情况下，ArgumentParser对象将命令行帮助消息中的 <code>description</code>和 <code>epilog</code> 文本换行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(</span><br><span class="line">...     prog=&#x27;PROG&#x27;,</span><br><span class="line">...     description=&#x27;&#x27;&#x27;this description</span><br><span class="line">...         was indented weird</span><br><span class="line">...             but that is okay&#x27;&#x27;&#x27;,</span><br><span class="line">...     epilog=&#x27;&#x27;&#x27;</span><br><span class="line">...             likewise for this epilog whose whitespace will</span><br><span class="line">...         be cleaned up and whose words will be wrapped</span><br><span class="line">...         across a couple lines&#x27;&#x27;&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: PROG [-h]</span><br><span class="line"></span><br><span class="line">this description was indented weird but that is okay</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"></span><br><span class="line">likewise for this epilog whose whitespace will be cleaned up and whose words</span><br><span class="line">will be wrapped across a couple lines</span><br></pre></td></tr></table></figure>
<p><code>RawDescriptionHelpFormatter</code>作为<code>formatter_class=</code> 指示<code>description</code>和 <code>epilog</code>已经被正确格式化并且不应该被行包裹传递：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(</span><br><span class="line">...     prog=&#x27;PROG&#x27;,</span><br><span class="line">...     formatter_class=argparse.RawDescriptionHelpFormatter,</span><br><span class="line">...     description=textwrap.dedent(&#x27;&#x27;&#x27;\</span><br><span class="line">...         Please do not mess up this text!</span><br><span class="line">...         --------------------------------</span><br><span class="line">...             I have indented it</span><br><span class="line">...             exactly the way</span><br><span class="line">...             I want it</span><br><span class="line">...         &#x27;&#x27;&#x27;))</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: PROG [-h]</span><br><span class="line"></span><br><span class="line">Please do not mess up this text!</span><br><span class="line">--------------------------------</span><br><span class="line">   I have indented it</span><br><span class="line">   exactly the way</span><br><span class="line">   I want it</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br></pre></td></tr></table></figure>
<p><code>RawTextHelpFormatter</code>为各种帮助文本保留空格，包括参数说明。但是，多个新行被替换为一个。如果您希望保留多个空行，请在换行符之间添加空格。</p>
<p>其他格式化程序类可用，<code>ArgumentDefaultsHelpFormatter</code>将添加有关每个参数的默认值的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(</span><br><span class="line">...     prog=&#x27;PROG&#x27;,</span><br><span class="line">...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, type=int, default=42, help=&#x27;FOO!&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, nargs=&#x27;*&#x27;, default=[1, 2, 3], help=&#x27;BAR!&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar [bar ...]]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar         BAR! (default: [1, 2, 3])</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo FOO   FOO! (default: 42)</span><br></pre></td></tr></table></figure>
<h3 id="prefix-chars"><a href="#prefix-chars" class="headerlink" title="prefix_chars"></a>prefix_chars</h3><p>大多数命令行选项将<code>-</code>用作前缀，例如<code>-f/--foo</code>。需要支持不同或额外前缀字符的解析器，例如像<code>+for</code>或<code>/foo</code>这样的选项，可以使用<code>prefix_chars=</code>参数来指定它们：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;, prefix_chars=&#x27;-+&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;+f&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;++bar&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;+f X ++bar Y&#x27;.split())</span><br><span class="line">Namespace(bar=&#x27;Y&#x27;, f=&#x27;X&#x27;)</span><br></pre></td></tr></table></figure>
<p>该<code>prefix_chars=</code>参数默认为<code>&#39;-&#39;</code>。提供一组不包含的字符<code>-</code>将导致<code>-f/--foo</code>选项不被允许。</p>
<h3 id="fromfile-prefix-chars"><a href="#fromfile-prefix-chars" class="headerlink" title="fromfile_prefix_chars"></a>fromfile_prefix_chars</h3><p>有时候，例如当处理特别长的参数列表时，将参数列表保存在文件中而不是在命令行输入它可能是有意义的。如果将<code>fromfile_prefix_chars=</code>参数赋予 ArgumentParser构造函数，那么以任何指定字符开头的参数将被视为文件，并将被它们包含的参数替换。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&#x27;args.txt&#x27;, &#x27;w&#x27;) as fp:</span><br><span class="line">...     fp.write(&#x27;-f\nbar&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(fromfile_prefix_chars=&#x27;@&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-f&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-f&#x27;, &#x27;foo&#x27;, &#x27;@args.txt&#x27;])</span><br><span class="line">Namespace(f=&#x27;bar&#x27;)</span><br></pre></td></tr></table></figure>
<p>从文件中读取的参数必须默认为每行一个（但也可参见<code>convert_arg_line_to_args()</code>），并且将它们视为与命令行中原始文件引用参数位于同一位置。所以在上面的例子中，表达式<code>[&#39;-f&#39;, &#39;foo&#39;, &#39;@args.txt&#39;]</code>被认为等同于表达式<code>[&#39;-f&#39;, &#39;foo&#39;, &#39;-f&#39;, &#39;bar&#39;]</code>.</p>
<p>该<code>fromfile_prefix_chars=</code>参数默认为None，这意味着参数就永远不会文件引用处理。</p>
<h3 id="argument-default"><a href="#argument-default" class="headerlink" title="argument_default"></a>argument_default</h3><p>一般来说，参数默认值是通过传递一个默认值给<code>add_argument()</code>来指定，或者通过调用<code>set_defaults()</code>具有一组特定名称/值对的 方法来指定参数默认值。然而，有时候，为参数指定单个解析器范围的默认值可能很有用。这可以通过传递 <code>argument_default=</code>关键字参数来完成ArgumentParser。例如，要全局大写<code>parse_args()</code>调用中的属性创建，我们提供<code>argument_default=SUPPRESS</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, nargs=&#x27;?&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--foo&#x27;, &#x27;1&#x27;, &#x27;BAR&#x27;])</span><br><span class="line">Namespace(bar=&#x27;BAR&#x27;, foo=&#x27;1&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">Namespace()</span><br></pre></td></tr></table></figure>
<h3 id="conflict-handler"><a href="#conflict-handler" class="headerlink" title="conflict_handler"></a>conflict_handler</h3><p>ArgumentParser对象不允许具有相同选项字符串的两个操作。默认情况下，ArgumentParser如果尝试使用已在使用的选项字符串创建参数，则会引发异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-f&#x27;, &#x27;--foo&#x27;, help=&#x27;old foo help&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, help=&#x27;new foo help&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> ..</span><br><span class="line">ArgumentError: argument --foo: conflicting option string(s): --foo</span><br></pre></td></tr></table></figure>
<p>有时（例如，在使用<code>parents</code>时），使用相同的选项字符串覆盖任何较旧的参数可能会很有用。为了获得这种行为，值 <code>&#39;resolve&#39;</code>可以提供给ArgumentParser的<code>conflict_handler=</code>参数 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;, conflict_handler=&#x27;resolve&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-f&#x27;, &#x27;--foo&#x27;, help=&#x27;old foo help&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, help=&#x27;new foo help&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: PROG [-h] [-f FOO] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> -f FOO      old foo help</span><br><span class="line"> --foo FOO   new foo help</span><br></pre></td></tr></table></figure>
<p>请注意，ArgumentParser如果对象的所有选项字符串都被覆盖，对象只会删除一个操作。因此，在上面的示例中，<code>old -f/--foo</code> 操作保留为<code>-f</code>操作，因为只有<code>--foo</code>选项字符串被覆盖。</p>
<h3 id="add-help"><a href="#add-help" class="headerlink" title="add_help"></a>add_help</h3><p>默认情况下，ArgumentParser对象添加一个选项，该选项只显示解析器的帮助消息。例如，考虑一个名为myprogram.py包含以下代码的文件 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--foo&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;foo help&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>
<p>如果<code>-h</code>或<code>--help</code>在命令行中提供，则会打印参数帮助器的帮助：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python myprogram.py --help</span><br><span class="line">usage: myprogram.py [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo FOO   foo help</span><br></pre></td></tr></table></figure>
<p>偶尔，禁用此帮助选项可能会有用。这可以通过<code>add_help=False</code>参数传递给 ArgumentParser：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;, add_help=False)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, help=&#x27;foo help&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: PROG [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> --foo FOO  foo help</span><br></pre></td></tr></table></figure>
<p>帮助选项通常是<code>-h/--help</code>。这是一个例外，如果<code>prefix_chars=</code>指定并且不包括<code>-</code>，在这种情况下<code>-h</code>和<code>--help</code>不是有效的选项。在这种情况下，<code>prefix_chars</code>第一个字符用于作为帮助选项的前缀：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;, prefix_chars=&#x27;+/&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: PROG [+h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  +h, ++help  show this help message and exit</span><br></pre></td></tr></table></figure>
<h2 id="The-add-argument-method"><a href="#The-add-argument-method" class="headerlink" title="The add_argument() method"></a>The add_argument() method</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])</span><br></pre></td></tr></table></figure>
<p>定义如何解析单个命令行参数。下面的每个参数都有自己的更详细的描述：</p>
<ul>
<li><code>name or flags</code> - Either a name or a list of option strings, e.g. <code>foo</code> or <code>-f, --foo</code>.</li>
<li><code>action</code> - The basic type of action to be taken when this argument is encountered at the command line.</li>
<li><code>nargs</code> - The number of command-line arguments that should be consumed.</li>
<li><code>const</code> - A constant value required by some action and nargs selections.</li>
<li><code>default</code> - The value produced if the argument is absent from the command line.</li>
<li><code>type</code> - The type to which the command-line argument should be converted.</li>
<li><code>choices</code> - A container of the allowable values for the argument.</li>
<li><code>required</code> - Whether or not the command-line option may be omitted (optionals only).</li>
<li><code>help</code> - A brief description of what the argument does.</li>
<li><code>metavar</code> - A name for the argument in usage messages.</li>
<li><code>dest</code> - The name of the attribute to be added to the object returned by <code>parse_args()</code>.</li>
</ul>
<p>以下部分描述如何使用每个这些。</p>
<h3 id="name-or-flags"><a href="#name-or-flags" class="headerlink" title="name or flags"></a>name or flags</h3><p><code>add_argument()</code>方法必须知道是否需要一个可选参数，如<code>-f</code>或<code>--foo</code>，或<code>positional argument</code>（如文件名列表）。因此传递给<code>add_argument()</code>的第一个参数必须是一系列flags或一个简单的参数name。例如，可以创建一个可选参数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-f&#x27;, &#x27;--foo&#x27;)</span><br></pre></td></tr></table></figure>
<p>而一个<code>positional argument</code>可以创建如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;)</span><br></pre></td></tr></table></figure>
<p>当<code>parse_args()</code>被调用时，可选参数将由<code>-</code>前缀标识，其余参数将被假定为position：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-f&#x27;, &#x27;--foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;BAR&#x27;])</span><br><span class="line">Namespace(bar=&#x27;BAR&#x27;, foo=None)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;BAR&#x27;, &#x27;--foo&#x27;, &#x27;FOO&#x27;])</span><br><span class="line">Namespace(bar=&#x27;BAR&#x27;, foo=&#x27;FOO&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--foo&#x27;, &#x27;FOO&#x27;])</span><br><span class="line">usage: PROG [-h] [-f FOO] bar</span><br><span class="line">PROG: error: too few arguments</span><br></pre></td></tr></table></figure>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>ArgumentParser对象将命令行参数与操作相关联。这些操作可以完成任何与它们相关的命令行参数的任何操作，尽管大多数操作只是为<code>parse_args()</code>返回的对象添加一个属性 。<code>action</code>关键字参数指定命令行参数应该如何处理。提供的操作是：</p>
<ul>
<li><code>&#39;store&#39;</code> - 这只是存储参数的值。这是默认操作。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;--foo 1&#x27;.split())</span><br><span class="line">Namespace(foo=&#x27;1&#x27;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#39;store_const&#39;</code>- 这存储由const关键字参数指定的值。<code>&#39;store_const&#39;</code>操作最常用于指定某种flag的可选参数。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, action=&#x27;store_const&#x27;, const=42)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--foo&#x27;])</span><br><span class="line">Namespace(foo=42)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#39;store_true&#39;</code>和<code>&#39;store_false&#39;</code>-这些都是特殊情况下 <code>&#39;store_const&#39;</code>使用，分别用于存储值True和False 。此外，他们分别创造的默认值False和True 。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, action=&#x27;store_true&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--bar&#x27;, action=&#x27;store_false&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--baz&#x27;, action=&#x27;store_false&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;--foo --bar&#x27;.split())</span><br><span class="line">Namespace(bar=False, baz=True, foo=True)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#39;append&#39;</code> - 这存储一个列表，并将每个参数值附加到列表中。这对于允许多次指定选项很有用。用法示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, action=&#x27;append&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;--foo 1 --foo 2&#x27;.split())</span><br><span class="line">Namespace(foo=[&#x27;1&#x27;, &#x27;2&#x27;])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#39;append_const&#39;</code>- 存储一个列表，并将const关键字参数指定的值附加到列表中。（请注意，<code>const</code>关键字参数默认为<code>None</code>。）<code>&#39;append_const&#39;</code>当多个参数需要将常量存储到同一列表时，该操作通常很有用。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--str&#x27;, dest=&#x27;types&#x27;, action=&#x27;append_const&#x27;, const=str)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--int&#x27;, dest=&#x27;types&#x27;, action=&#x27;append_const&#x27;, const=int)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;--str --int&#x27;.split())</span><br><span class="line">Namespace(types=[&lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;int&#x27;&gt;])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#39;count&#39;</code> - 这会计算关键字参数发生的次数。例如，这对增加冗长级别很有用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--verbose&#x27;, &#x27;-v&#x27;, action=&#x27;count&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-vvv&#x27;])</span><br><span class="line">Namespace(verbose=3)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>&#39;help&#39;</code> - 这将显示当前解析器中所有选项的完整帮助消息，然后退出。默认情况下，帮助操作会自动添加到解析器中。请参阅ArgumentParser有关如何创建输出的详细信息。</p>
</li>
<li><p><code>&#39;version&#39;</code>- 这需要调用<code>add_argument()</code>中的<code>version=</code>关键字参数 ，并打印版本信息并在调用时退出：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import argparse</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--version&#x27;, action=&#x27;version&#x27;, version=&#x27;%(prog)s 2.0&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--version&#x27;])</span><br><span class="line">PROG 2.0</span><br></pre></td></tr></table></figure>
<p>您也可以通过传递一个Action子类或其他实现相同接口的对象来指定一个任意的动作。推荐的方法是扩展<code>Action</code>，覆盖<code>__call__</code>方法和可选的<code>__init__</code>方法。</p>
<p>自定义操作的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class FooAction(argparse.Action):</span><br><span class="line">...     def __init__(self, option_strings, dest, nargs=None, **kwargs):</span><br><span class="line">...         if nargs is not None:</span><br><span class="line">...             raise ValueError(&quot;nargs not allowed&quot;)</span><br><span class="line">...         super(FooAction, self).__init__(option_strings, dest, **kwargs)</span><br><span class="line">...     def __call__(self, parser, namespace, values, option_string=None):</span><br><span class="line">...         print &#x27;%r %r %r&#x27; % (namespace, values, option_string)</span><br><span class="line">...         setattr(namespace, self.dest, values)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, action=FooAction)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, action=FooAction)</span><br><span class="line">&gt;&gt;&gt; args = parser.parse_args(&#x27;1 --foo 2&#x27;.split())</span><br><span class="line">Namespace(bar=None, foo=None) &#x27;1&#x27; None</span><br><span class="line">Namespace(bar=&#x27;1&#x27;, foo=None) &#x27;2&#x27; &#x27;--foo&#x27;</span><br><span class="line">&gt;&gt;&gt; args</span><br><span class="line">Namespace(bar=&#x27;1&#x27;, foo=&#x27;2&#x27;)</span><br></pre></td></tr></table></figure>
<p>有关更多详情，请参阅Action。</p>
<h3 id="nargs"><a href="#nargs" class="headerlink" title="nargs"></a>nargs</h3><p>ArgumentParser对象通常会将单个命令行参数与要执行的单个操作相关联。<code>nargs</code>关键字参数将不同数量的命令行参数和与单个动作关联起来。支持的值是：</p>
<ul>
<li><code>N</code>（一个整数）。 命令行中的<code>N</code>参数将汇集到一个列表中。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, nargs=2)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, nargs=1)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;c --foo a b&#x27;.split())</span><br><span class="line">Namespace(bar=[&#x27;c&#x27;], foo=[&#x27;a&#x27;, &#x27;b&#x27;])</span><br></pre></td></tr></table></figure>
<p>请注意，<code>nargs=1</code>生成一个项目的列表。这与项目自行生成的默认值不同。</p>
<ul>
<li><code>&#39;?&#39;</code>。如有可能，将从命令行中消耗一个参数，并将其作为单个项目生成。如果没有命令行参数，则会生成默认值 。请注意，对于可选参数，还有一个额外的情况 - 选项字符串存在，但后面没有命令行参数。在这种情况下，<code>const</code>的值将被生成。一些例子来说明这一点：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, nargs=&#x27;?&#x27;, const=&#x27;c&#x27;, default=&#x27;d&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, nargs=&#x27;?&#x27;, default=&#x27;d&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;XX&#x27;, &#x27;--foo&#x27;, &#x27;YY&#x27;])</span><br><span class="line">Namespace(bar=&#x27;XX&#x27;, foo=&#x27;YY&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;XX&#x27;, &#x27;--foo&#x27;])</span><br><span class="line">Namespace(bar=&#x27;XX&#x27;, foo=&#x27;c&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">Namespace(bar=&#x27;d&#x27;, foo=&#x27;d&#x27;)</span><br></pre></td></tr></table></figure>
<p>更常见的<code>nargs=&#39;?&#39;</code>用途之一是允许可选的输入和输出文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;infile&#x27;, nargs=&#x27;?&#x27;, type=argparse.FileType(&#x27;r&#x27;),</span><br><span class="line">...                     default=sys.stdin)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;outfile&#x27;, nargs=&#x27;?&#x27;, type=argparse.FileType(&#x27;w&#x27;),</span><br><span class="line">...                     default=sys.stdout)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;input.txt&#x27;, &#x27;output.txt&#x27;])</span><br><span class="line">Namespace(infile=&lt;open file &#x27;input.txt&#x27;, mode &#x27;r&#x27; at 0x...&gt;,</span><br><span class="line">          outfile=&lt;open file &#x27;output.txt&#x27;, mode &#x27;w&#x27; at 0x...&gt;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">Namespace(infile=&lt;open file &#x27;&lt;stdin&gt;&#x27;, mode &#x27;r&#x27; at 0x...&gt;,</span><br><span class="line">          outfile=&lt;open file &#x27;&lt;stdout&gt;&#x27;, mode &#x27;w&#x27; at 0x...&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#39;*&#39;</code>。所有存在的命令行参数都被收集到一个列表中。请注意，<code>nargs=&#39;*&#39;</code>具有多个位置参数通常没有多大意义，但<code>nargs=&#39;*&#39;</code>可以使用多个可选参数。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, nargs=&#x27;*&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--bar&#x27;, nargs=&#x27;*&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;baz&#x27;, nargs=&#x27;*&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;a b --foo x y --bar 1 2&#x27;.split())</span><br><span class="line">Namespace(bar=[&#x27;1&#x27;, &#x27;2&#x27;], baz=[&#x27;a&#x27;, &#x27;b&#x27;], foo=[&#x27;x&#x27;, &#x27;y&#x27;])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&#39;+&#39;</code>。就像<code>&#39;*&#39;</code>，现在所有的命令行参数都被收集到一个列表中。此外，如果没有至少一个命令行参数，则会生成错误消息。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;foo&#x27;, nargs=&#x27;+&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;a&#x27;, &#x27;b&#x27;])</span><br><span class="line">Namespace(foo=[&#x27;a&#x27;, &#x27;b&#x27;])</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">usage: PROG [-h] foo [foo ...]</span><br><span class="line">PROG: error: too few arguments</span><br></pre></td></tr></table></figure>
<ul>
<li><code>argparse.REMAINDER</code>。所有其余的命令行参数都被收集到一个列表中。这对于派发到其他命令行实用程序的命令行实用程序通常很有用：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;command&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;args&#x27;, nargs=argparse.REMAINDER)</span><br><span class="line">&gt;&gt;&gt; print parser.parse_args(&#x27;--foo B cmd --arg1 XX ZZ&#x27;.split())</span><br><span class="line">Namespace(args=[&#x27;--arg1&#x27;, &#x27;XX&#x27;, &#x27;ZZ&#x27;], command=&#x27;cmd&#x27;, foo=&#x27;B&#x27;)</span><br></pre></td></tr></table></figure>
<p>如果<code>nargs</code>没有提供关键字参数，则消耗的参数数量由<code>action</code>决定。通常这意味着一个命令行参数将被消耗，并且将生成单个项目（不是列表）。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>add_argument()</code>的<code>const</code>参数是用来装未在命令行中读取但ArgumentParser的<code>action</code>所需要的各种常数值。它最常见的两种用途是：</p>
<ul>
<li>当<code>add_argument()</code>调用<code>action=&#39;store_const&#39;</code> 或者<code>action=&#39;append_const&#39;</code>。这些<code>action</code>将<code>const</code>值添加到返回的对象的某个属性中 。有关示例，请参阅<code>action</code>说明。</li>
<li>当<code>add_argument()</code>用选项字符串（如<code>-f</code> or <code>--foo</code>）和<code>nargs=&#39;?&#39;</code>时。这会创建一个可选参数，后面跟零个或一个命令行参数。在解析命令行时，如果选项字符串遇到后面没有命令行参数，<code>const</code>的值则会取而代之。有关示例，请参阅<code>nargs</code>说明。</li>
</ul>
<p>使用<code>&#39;store_const&#39;</code>和<code>&#39;append_const&#39;</code>操作时，<code>const</code>必须给出关键字参数。对于其他操作，它默认为<code>None</code>。</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>所有可选参数和一些位置参数可以在命令行中省略。如果命令行参数不存在，那么<code>add_argument()</code>的<code>default</code>关键字参数其值缺省为<code>None</code>将指定应使用的值。对于可选参数，default当选项字符串不存在于命令行时，将使用该值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, default=42)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--foo&#x27;, &#x27;2&#x27;])</span><br><span class="line">Namespace(foo=&#x27;2&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">Namespace(foo=42)</span><br></pre></td></tr></table></figure>
<p>如果该<code>default</code>值是一个字符串，则解析器会将该值解析为一个命令行参数。特别是， 解析器在设置Namespace返回值的属性之前应用任何类型转换参数（如果提供的话）。否则，解析器按原样使用该值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--length&#x27;, default=&#x27;10&#x27;, type=int)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--width&#x27;, default=10.5, type=int)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args()</span><br><span class="line">Namespace(length=10, width=10.5)</span><br></pre></td></tr></table></figure>
<p>对于<code>nargs</code>等于<code>?</code>or<code>*</code>的<code>position</code>参数，当没有命令行参数存在时使用<code>default</code>值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;foo&#x27;, nargs=&#x27;?&#x27;, default=42)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;a&#x27;])</span><br><span class="line">Namespace(foo=&#x27;a&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">Namespace(foo=42)</span><br></pre></td></tr></table></figure>
<p>如果命令行参数不存在，则提供<code>default=argparse.SUPPRESS</code>不导致添加属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, default=argparse.SUPPRESS)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">Namespace()</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--foo&#x27;, &#x27;1&#x27;])</span><br><span class="line">Namespace(foo=&#x27;1&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>默认情况下，ArgumentParser对象以简单的字符串读取命令行参数。但是，通常命令行字符串应该被解释为另一种类型，如<code>float</code>或<code>int</code>。所述<code>add_argument()</code>的关键字<code>type</code>参数允许执行任何必要的类型检查和类型转换。常见的内置类型和函数可以直接用作type参数的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;foo&#x27;, type=int)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, type=file)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;2 temp.txt&#x27;.split())</span><br><span class="line">Namespace(bar=&lt;open file &#x27;temp.txt&#x27;, mode &#x27;r&#x27; at 0x...&gt;, foo=2)</span><br></pre></td></tr></table></figure>
<p>有关何时将参数应用于默认参数的信息，请参阅default关键字参数 部分type。</p>
<p>为了简化各种类型的文件的使用，argparse模块提供了factory FileType类型，<code>file</code>类型包含对象的参数<code>mode=</code>和<code>bufsize=</code>参数。例如，<code>FileType(&#39;w&#39;)</code>可以用来创建一个可写文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, type=argparse.FileType(&#x27;w&#x27;))</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;out.txt&#x27;])</span><br><span class="line">Namespace(bar=&lt;open file &#x27;out.txt&#x27;, mode &#x27;w&#x27; at 0x...&gt;)</span><br></pre></td></tr></table></figure>
<p><code>type=</code>可以采用任何可以调用单个字符串参数的可调用方法，并返回转换后的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def perfect_square(string):</span><br><span class="line">...     value = int(string)</span><br><span class="line">...     sqrt = math.sqrt(value)</span><br><span class="line">...     if sqrt != int(sqrt):</span><br><span class="line">...         msg = &quot;%r is not a perfect square&quot; % string</span><br><span class="line">...         raise argparse.ArgumentTypeError(msg)</span><br><span class="line">...     return value</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;foo&#x27;, type=perfect_square)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;9&#x27;])</span><br><span class="line">Namespace(foo=9)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;7&#x27;])</span><br><span class="line">usage: PROG [-h] foo</span><br><span class="line">PROG: error: argument foo: &#x27;7&#x27; is not a perfect square</span><br></pre></td></tr></table></figure>
<p><code>choices</code>关键字参数可以是用于类型检查，简单地核对值的范围更方便：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;foo&#x27;, type=int, choices=xrange(5, 10))</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;7&#x27;])</span><br><span class="line">Namespace(foo=7)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;11&#x27;])</span><br><span class="line">usage: PROG [-h] &#123;5,6,7,8,9&#125;</span><br><span class="line">PROG: error: argument foo: invalid choice: 11 (choose from 5, 6, 7, 8, 9)</span><br></pre></td></tr></table></figure>
<p>请参阅<code>choices</code>部分了解更多详情。</p>
<h3 id="choices"><a href="#choices" class="headerlink" title="choices"></a>choices</h3><p>一些命令行参数应该从一组受限制的值中选择。这些可以通过将容器对象作为选择关键字参数传递给<code>add_argument()</code>。在解析命令行时，将检查参数值，如果参数不是可接受值之一，则会显示错误消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;game.py&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;move&#x27;, choices=[&#x27;rock&#x27;, &#x27;paper&#x27;, &#x27;scissors&#x27;])</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;rock&#x27;])</span><br><span class="line">Namespace(move=&#x27;rock&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;fire&#x27;])</span><br><span class="line">usage: game.py [-h] &#123;rock,paper,scissors&#125;</span><br><span class="line">game.py: error: argument move: invalid choice: &#x27;fire&#x27; (choose from &#x27;rock&#x27;,</span><br><span class="line">&#x27;paper&#x27;, &#x27;scissors&#x27;)</span><br></pre></td></tr></table></figure>
<p>请注意，在执行任何类型转换后，将检查包含在choices容器中的内容，以便choices容器中的对象类型与指定的类型匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;doors.py&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;door&#x27;, type=int, choices=range(1, 4))</span><br><span class="line">&gt;&gt;&gt; print(parser.parse_args([&#x27;3&#x27;]))</span><br><span class="line">Namespace(door=3)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;4&#x27;])</span><br><span class="line">usage: doors.py [-h] &#123;1,2,3&#125;</span><br><span class="line">doors.py: error: argument door: invalid choice: 4 (choose from 1, 2, 3)</span><br></pre></td></tr></table></figure>
<p>任何支持<code>in</code>操作符的对象都可以作为choices 值传递，因此所有<code>dict</code>对象，<code>set</code>对象，自定义容器等都是受支持的。</p>
<h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><p>通常情况下，argparse模块假定标志像<code>-f</code>和<code>--bar</code> 表示可选参数，这些参数在命令行中总是可以省略。要创建所需的选项，<code>add_argument()</code>可以指定<code>required=</code>关键字参数为<code>True</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, required=True)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--foo&#x27;, &#x27;BAR&#x27;])</span><br><span class="line">Namespace(foo=&#x27;BAR&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">usage: argparse.py [-h] [--foo FOO]</span><br><span class="line">argparse.py: error: option --foo is required</span><br></pre></td></tr></table></figure>
<p>如示例所示，如果某个选项被标记为<code>required</code>， <code>parse_args()</code>则会在命令行中不存在该选项时报告错误。</p>
<p>注意 所需的选项通常被认为是不好的形式，因为用户期望 选项是可选的，因此应尽可能避免。</p>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><code>help</code>值是一个包含参数简要描述的字符串。当用户请求帮助时（通常通过使用<code>-h</code>或<code>--help</code>命令行），这些<code>help</code>描述将与每个参数一起显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;frobble&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, action=&#x27;store_true&#x27;,</span><br><span class="line">...                     help=&#x27;foo the bars before frobbling&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, nargs=&#x27;+&#x27;,</span><br><span class="line">...                     help=&#x27;one of the bars to be frobbled&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-h&#x27;])</span><br><span class="line">usage: frobble [-h] [--foo] bar [bar ...]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar     one of the bars to be frobbled</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo   foo the bars before frobbling</span><br></pre></td></tr></table></figure>
<p>这些<code>help</code>字符串可以包含各种格式说明符，以避免重复诸如程序名称或参数默认值之类的内容。可用符包括程序名称，<code>%(prog)s</code>和<code>add_argument()</code>的大多数关键字参数，如<code>%(default)s</code>，<code>%(type)s</code>等：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;frobble&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, nargs=&#x27;?&#x27;, type=int, default=42,</span><br><span class="line">...                     help=&#x27;the bar to %(prog)s (default: %(default)s)&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: frobble [-h] [bar]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar     the bar to frobble (default: 42)</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br></pre></td></tr></table></figure>
<p>argparse支持通过将某些选项的帮助条目设置<code>help</code>为<code>argparse.SUPPRESS</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;frobble&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, help=argparse.SUPPRESS)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: frobble [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message and exit</span><br></pre></td></tr></table></figure>
<h3 id="metavar"><a href="#metavar" class="headerlink" title="metavar"></a>metavar</h3><p>当ArgumentParser生成帮助消息时，需要一些方法来引用每个预期的参数。默认情况下，ArgumentParser对象使用<code>dest</code>值作为每个对象的“名称”。默认情况下，对于位置参数操作，<code>dest</code>值直接使用，对于可选参数操作，<code>dest</code>值是大写的。所以，一个单独的位置参数 <code>dest=&#39;bar&#39;</code>将被称为<code>bar</code>。<code>--foo</code>单个命令行参数后面的单个可选参数将被称为<code>FOO</code>。一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;X --foo Y&#x27;.split())</span><br><span class="line">Namespace(bar=&#x27;X&#x27;, foo=&#x27;Y&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage:  [-h] [--foo FOO] bar</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo FOO</span><br></pre></td></tr></table></figure>
<p>另一个名称可以用以下方式指定<code>metavar</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, metavar=&#x27;YYY&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, metavar=&#x27;XXX&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;X --foo Y&#x27;.split())</span><br><span class="line">Namespace(bar=&#x27;X&#x27;, foo=&#x27;Y&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage:  [-h] [--foo YYY] XXX</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> XXX</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo YYY</span><br></pre></td></tr></table></figure>
<p>请注意，metavar只会更改显示的名称 - <code>parse_args()</code>对象上属性的名称仍由<code>dest</code>值确定。</p>
<p>不同的值<code>nargs</code>可能会导致<code>metavar</code>被多次使用。提供一个元组<code>metavar</code>为每个参数指定一个不同的显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-x&#x27;, nargs=2)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, nargs=2, metavar=(&#x27;bar&#x27;, &#x27;baz&#x27;))</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: PROG [-h] [-x X X] [--foo bar baz]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help     show this help message and exit</span><br><span class="line"> -x X X</span><br><span class="line"> --foo bar baz</span><br></pre></td></tr></table></figure>
<h3 id="dest"><a href="#dest" class="headerlink" title="dest"></a>dest</h3><p>大多数ArgumentParser操作都会添加一些值作为<code>parse_args()</code>返回对象的属性。该属性的名称由<code>add_argument()</code>关键字参数<code>dest</code>确定 。对于位置参数操作， <code>dest</code>通常作为第一个参数提供给<code>add_argument()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;XXX&#x27;])</span><br><span class="line">Namespace(bar=&#x27;XXX&#x27;)</span><br></pre></td></tr></table></figure>
<p>对于可选的参数操作，<code>dest</code>通常从选项字符串推断值。 通过取第一个长选项字符串并剥离初始 <code>--</code>字符串来生成<code>dest</code>值。如果没有提供长选项字符串，则将通过剥离初始字符从第一个短选项字符串派生。任何内部字符都将转换为<code>_</code>字符以确保该字符串是有效的属性名称。下面的例子说明了这种行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-f&#x27;, &#x27;--foo-bar&#x27;, &#x27;--foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-x&#x27;, &#x27;-y&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;-f 1 -x 2&#x27;.split())</span><br><span class="line">Namespace(foo_bar=&#x27;1&#x27;, x=&#x27;2&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;--foo 1 -y 2&#x27;.split())</span><br><span class="line">Namespace(foo_bar=&#x27;1&#x27;, x=&#x27;2&#x27;)</span><br></pre></td></tr></table></figure>
<p><code>dest</code> 允许提供自定义属性名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, dest=&#x27;bar&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;--foo XXX&#x27;.split())</span><br><span class="line">Namespace(bar=&#x27;XXX&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="Action-classes"><a href="#Action-classes" class="headerlink" title="Action classes"></a>Action classes</h3><p>Action类实现Action API，这是一个可调用的函数，它返回一个可从命令行处理参数的可调用对象。任何遵循此API的对象都可以作为<code>action</code>参数传递给<code>add_argument()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class argparse.Action（option_strings，dest，nargs = None，const = None，default = None，type = None，choices = None，required = False，help = None，metavar = None ）</span><br></pre></td></tr></table></figure>
<p>ArgumentParser使用Action对象来表示解析来自命令行的一个或多个字符串的单个参数所需的信息。Action类必须接受两个位置参数以及传递给<code>ArgumentParser.add_argument()</code>除action它自身以外的任何关键字参数。</p>
<p>Action的实例（或任何可调用的<code>action</code>参数的返回值）应该具有定义的属性“dest”, “option<em>strings”, “default”, “type”, “required”, “help”等。确定这些属性的最简单方法是调用`Action.<em>_init</em></em>`。</p>
<p>动作实例应该是可调用的，所以子类必须重载该 <code>__call__</code>方法，该方法应该接受四个参数：</p>
<ul>
<li><code>parser</code> - The ArgumentParser object which contains this action.</li>
<li><code>namespace</code> - The Namespace object that will be returned by parse_args(). Most actions add an attribute to this object using setattr().</li>
<li><code>values</code> - The associated command-line arguments, with any type conversions applied. Type conversions are specified with the type keyword argument to add_argument().</li>
<li><code>option_string</code>- The option string that was used to invoke this action. The option_string argument is optional, and will be absent if the action is associated with a positional argument.</li>
</ul>
<p><code>__call__</code>方法可能会执行任意操作，但通常会基于<code>dest</code>和<code>values</code>在<code>namespace</code>上设置属性。</p>
<h2 id="The-parse-args-method"><a href="#The-parse-args-method" class="headerlink" title="The parse_args() method"></a>The parse_args() method</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArgumentParser.parse_args（args = None，namespace = None ）</span><br></pre></td></tr></table></figure>
<p>将参数字符串转换为对象并将它们分配为命名空间的属性。返回填充的命名空间。</p>
<p>先前的调用<code>add_argument()</code>确切地确定创建了哪些对象以及如何分配对象。有关详细信息，请参阅<code>add_argument()</code>文档 。</p>
<ul>
<li>args - List of strings to parse. The default is taken from sys.argv.</li>
<li>namespace - An object to take the attributes. The default is a new empty Namespace object.</li>
</ul>
<h3 id="Option-value-syntax"><a href="#Option-value-syntax" class="headerlink" title="Option value syntax"></a>Option value syntax</h3><p><code>parse_args()</code>方法支持多种指定选项值的方式（如果需要的话）。在最简单的情况下，该选项及其值作为两个单独的参数传递：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-x&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-x&#x27;, &#x27;X&#x27;])</span><br><span class="line">Namespace(foo=None, x=&#x27;X&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--foo&#x27;, &#x27;FOO&#x27;])</span><br><span class="line">Namespace(foo=&#x27;FOO&#x27;, x=None)</span><br></pre></td></tr></table></figure>
<p>对于长选项（名称长于单个字符的选项），该选项和值也可以作为单个命令行参数传递，用<code>=</code>将它们分开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--foo=FOO&#x27;])</span><br><span class="line">Namespace(foo=&#x27;FOO&#x27;, x=None)</span><br></pre></td></tr></table></figure>
<p>对于短期选项（选项只有一个字符长），选项和它的值可以连接起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-xX&#x27;])</span><br><span class="line">Namespace(foo=None, x=&#x27;X&#x27;)</span><br></pre></td></tr></table></figure>
<p>使用一个<code>-</code>前缀，几个简短的选项就可以结合在一起，只要最后一个选项（或者它们中没有一个）需要一个值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-x&#x27;, action=&#x27;store_true&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-y&#x27;, action=&#x27;store_true&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-z&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-xyzZ&#x27;])</span><br><span class="line">Namespace(x=True, y=True, z=&#x27;Z&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="Invalid-arguments"><a href="#Invalid-arguments" class="headerlink" title="Invalid arguments"></a>Invalid arguments</h3><p>在解析命令行时，<code>parse_args()</code>检查各种错误，包括不明确的选项，无效的类型，无效的选项，错误的位置参数数量等。遇到此类错误时，它会退出并将错误与使用消息一起打印出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;, type=int)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;bar&#x27;, nargs=&#x27;?&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # invalid type</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--foo&#x27;, &#x27;spam&#x27;])</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar]</span><br><span class="line">PROG: error: argument --foo: invalid int value: &#x27;spam&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # invalid option</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--bar&#x27;])</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar]</span><br><span class="line">PROG: error: no such option: --bar</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # wrong number of arguments</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;spam&#x27;, &#x27;badger&#x27;])</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar]</span><br><span class="line">PROG: error: extra arguments found: badger</span><br></pre></td></tr></table></figure>
<h3 id="Arguments-containing"><a href="#Arguments-containing" class="headerlink" title="Arguments containing -"></a>Arguments containing -</h3><p>每当用户明确犯了错误，<code>parse_args()</code>方法都会尝试给出错误，但有些情况本质上是不明确的。例如，命令行参数<code>-1</code>可能是尝试指定选项或试图提供位置参数。<code>parse_args()</code>方法很谨慎：位置参数可能只有<code>-</code>在它们看起来像负数时才会开始，解析器中没有任何选项看起来像负数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-x&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;foo&#x27;, nargs=&#x27;?&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # no negative number options, so -1 is a positional argument</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-x&#x27;, &#x27;-1&#x27;])</span><br><span class="line">Namespace(foo=None, x=&#x27;-1&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # no negative number options, so -1 and -5 are positional arguments</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-x&#x27;, &#x27;-1&#x27;, &#x27;-5&#x27;])</span><br><span class="line">Namespace(foo=&#x27;-5&#x27;, x=&#x27;-1&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-1&#x27;, dest=&#x27;one&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;foo&#x27;, nargs=&#x27;?&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # negative number options present, so -1 is an option</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-1&#x27;, &#x27;X&#x27;])</span><br><span class="line">Namespace(foo=None, one=&#x27;X&#x27;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # negative number options present, so -2 is an option</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-2&#x27;])</span><br><span class="line">usage: PROG [-h] [-1 ONE] [foo]</span><br><span class="line">PROG: error: no such option: -2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # negative number options present, so both -1s are options</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;-1&#x27;, &#x27;-1&#x27;])</span><br><span class="line">usage: PROG [-h] [-1 ONE] [foo]</span><br><span class="line">PROG: error: argument -1: expected one argument</span><br></pre></td></tr></table></figure>
<p>如果您的位置参数必须以<code>-</code>开头且看起来不像负数，那么您可以插入伪参数’<code>--&#39;</code>， 该伪参数指示<code>--</code>之后的所有内容都是位置参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;--&#x27;, &#x27;-f&#x27;])</span><br><span class="line">Namespace(foo=&#x27;-f&#x27;, one=None)</span><br></pre></td></tr></table></figure>
<h3 id="Argument-abbreviations-prefix-matching"><a href="#Argument-abbreviations-prefix-matching" class="headerlink" title="Argument abbreviations (prefix matching)"></a>Argument abbreviations (prefix matching)</h3><p>parse_args()如果缩写是明确的（前缀匹配唯一选项），该方法允许将长选项缩写为前缀：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&#x27;PROG&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-bacon&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;-badger&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;-bac MMM&#x27;.split())</span><br><span class="line">Namespace(bacon=&#x27;MMM&#x27;, badger=None)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;-bad WOOD&#x27;.split())</span><br><span class="line">Namespace(bacon=None, badger=&#x27;WOOD&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&#x27;-ba BA&#x27;.split())</span><br><span class="line">usage: PROG [-h] [-bacon BACON] [-badger BADGER]</span><br><span class="line">PROG: error: ambiguous option: -ba could match -badger, -bacon</span><br></pre></td></tr></table></figure>
<p>对于可能产生多个选项的参数会产生错误。</p>
<h3 id="Beyond-sys-argv"><a href="#Beyond-sys-argv" class="headerlink" title="Beyond sys.argv"></a>Beyond sys.argv</h3><p>有时候可能有一个ArgumentParser解析其他的参数sys.argv。这可以通过传递一个字符串列表给<code>parse_args()</code>来完成 。这对于在交互式提示下进行测试很有用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(</span><br><span class="line">...     &#x27;integers&#x27;, metavar=&#x27;int&#x27;, type=int, choices=xrange(10),</span><br><span class="line">...     nargs=&#x27;+&#x27;, help=&#x27;an integer in the range 0..9&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(</span><br><span class="line">...     &#x27;--sum&#x27;, dest=&#x27;accumulate&#x27;, action=&#x27;store_const&#x27;, const=sum,</span><br><span class="line">...     default=max, help=&#x27;sum the integers (default: find the max)&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;])</span><br><span class="line">Namespace(accumulate=&lt;built-in function max&gt;, integers=[1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;--sum&#x27;])</span><br><span class="line">Namespace(accumulate=&lt;built-in function sum&gt;, integers=[1, 2, 3, 4])</span><br></pre></td></tr></table></figure>
<h3 id="The-Namespace-object"><a href="#The-Namespace-object" class="headerlink" title="The Namespace object"></a>The Namespace object</h3><blockquote>
<p>class argparse.Namespace<br>Simple class used by default by parse_args() to create an object holding attributes and return it.</p>
</blockquote>
<p>这个类很简单，只是一个object具有可读字符串表示的子类。如果您更喜欢使用类似字典的属性视图，则可以使用标准的Python语言vars()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; args = parser.parse_args([&#x27;--foo&#x27;, &#x27;BAR&#x27;])</span><br><span class="line">&gt;&gt;&gt; vars(args)</span><br><span class="line">&#123;&#x27;foo&#x27;: &#x27;BAR&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>ArgumentParser将属性赋值给已经存在的对象而不是新Namespace对象也可能是有用的。这可以通过指定<code>namespace=</code>关键字参数来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class C(object):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&#x27;--foo&#x27;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(args=[&#x27;--foo&#x27;, &#x27;BAR&#x27;], namespace=c)</span><br><span class="line">&gt;&gt;&gt; c.foo</span><br><span class="line">&#x27;BAR&#x27;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://busyboxs.github.io">Busyboxs</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://busyboxs.github.io/blogs/d66b5eb8/">https://busyboxs.github.io/blogs/d66b5eb8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://busyboxs.github.io" target="_blank">Busyboxs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blogs/fcf3e93f/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/arxiv.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">arxiv论文类别</div></div></a></div><div class="next-post pull-right"><a href="/blogs/2681bd6b/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/python.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Logging HowTO</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blogs/492c0a71/" title="math — Mathematical functions"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/python.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-24</div><div class="title">math — Mathematical functions</div></div></a></div><div><a href="/blogs/c80f2743/" title="Python notes"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/python.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-24</div><div class="title">Python notes</div></div></a></div><div><a href="/blogs/2681bd6b/" title="Logging HowTO"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/python.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-24</div><div class="title">Logging HowTO</div></div></a></div><div><a href="/blogs/fc4c67ff/" title="Python 函数中如何实现可变数目的参数"><img class="cover" src="https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/covers/python.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-27</div><div class="title">Python 函数中如何实现可变数目的参数</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Example"><span class="toc-number">1.</span> <span class="toc-text">Example</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Creating-a-parser"><span class="toc-number">1.1.</span> <span class="toc-text">Creating a parser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Adding-arguments"><span class="toc-number">1.2.</span> <span class="toc-text">Adding arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parsing-arguments"><span class="toc-number">1.3.</span> <span class="toc-text">Parsing arguments</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArgumentParser-objects"><span class="toc-number">2.</span> <span class="toc-text">ArgumentParser objects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prog"><span class="toc-number">2.1.</span> <span class="toc-text">prog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usage"><span class="toc-number">2.2.</span> <span class="toc-text">usage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#description"><span class="toc-number">2.3.</span> <span class="toc-text">description</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epilog"><span class="toc-number">2.4.</span> <span class="toc-text">epilog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parents"><span class="toc-number">2.5.</span> <span class="toc-text">parents</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#formatter-class"><span class="toc-number">2.6.</span> <span class="toc-text">formatter_class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prefix-chars"><span class="toc-number">2.7.</span> <span class="toc-text">prefix_chars</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fromfile-prefix-chars"><span class="toc-number">2.8.</span> <span class="toc-text">fromfile_prefix_chars</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#argument-default"><span class="toc-number">2.9.</span> <span class="toc-text">argument_default</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#conflict-handler"><span class="toc-number">2.10.</span> <span class="toc-text">conflict_handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-help"><span class="toc-number">2.11.</span> <span class="toc-text">add_help</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-add-argument-method"><span class="toc-number">3.</span> <span class="toc-text">The add_argument() method</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#name-or-flags"><span class="toc-number">3.1.</span> <span class="toc-text">name or flags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#action"><span class="toc-number">3.2.</span> <span class="toc-text">action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nargs"><span class="toc-number">3.3.</span> <span class="toc-text">nargs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">3.4.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#default"><span class="toc-number">3.5.</span> <span class="toc-text">default</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type"><span class="toc-number">3.6.</span> <span class="toc-text">type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#choices"><span class="toc-number">3.7.</span> <span class="toc-text">choices</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#required"><span class="toc-number">3.8.</span> <span class="toc-text">required</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#help"><span class="toc-number">3.9.</span> <span class="toc-text">help</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#metavar"><span class="toc-number">3.10.</span> <span class="toc-text">metavar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dest"><span class="toc-number">3.11.</span> <span class="toc-text">dest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Action-classes"><span class="toc-number">3.12.</span> <span class="toc-text">Action classes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-parse-args-method"><span class="toc-number">4.</span> <span class="toc-text">The parse_args() method</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Option-value-syntax"><span class="toc-number">4.1.</span> <span class="toc-text">Option value syntax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Invalid-arguments"><span class="toc-number">4.2.</span> <span class="toc-text">Invalid arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arguments-containing"><span class="toc-number">4.3.</span> <span class="toc-text">Arguments containing -</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Argument-abbreviations-prefix-matching"><span class="toc-number">4.4.</span> <span class="toc-text">Argument abbreviations (prefix matching)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Beyond-sys-argv"><span class="toc-number">4.5.</span> <span class="toc-text">Beyond sys.argv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Namespace-object"><span class="toc-number">4.6.</span> <span class="toc-text">The Namespace object</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/busyboxs/CDN@latest/img/archive_img.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By Busyboxs</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">❤🦋Stay foolish. Stay hungry.🦋❤</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="爱你哟,好好学习，天天向上,Stay hungry. Stay foolish.,✨✨✨,🎈🎈🎈,🎮🎮,♥♥♥♥,🏐🏐,🪂🪂" data-fontsize="10px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>